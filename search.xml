<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>反转字符串中的单词</title>
    <url>/post/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。</p>
<p>示例:<br>输入: <code>&quot;Let&#39;s take LeetCode contest&quot;</code><br>输出: <code>&quot;s&#39;teL ekat edoCteeL tsetnoc&quot;</code><br>注意：在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。</p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>JavaScript 没有提供颠倒字符串的能力，只有一个数组方法 <code>reverse()</code> 可以颠倒数组元素的位置。比如，现有数组 <code>arr</code> 为 <code>[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</code>，应用 <code>reverse()</code> 方法后得到：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> result = arr.reverse();</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// [&#x27;c&#x27;, &#x27;b&#x27;, &#x27;a&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>利用 JavaScript 提供的字符串方法 <code>split()</code> 可以将一个字符串分割成以指定分隔符分隔的数组。下例，将一字符串分割成以字母为数组元素的数组：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;Welcome&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> resultArr = str.split(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(resultArr); <span class="comment">// [&#x27;W&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;c&#x27;, &#x27;o&#x27;, &#x27;m&#x27;, &#x27;e&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>将 <code>resultArr</code> 中数组元素颠倒位置后，再拼接为字符串，即可实现字符串的位置颠倒：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reversedArr = resultArr.reverse(); <span class="comment">// 得到颠倒后的数组</span></span><br><span class="line"><span class="keyword">const</span> reversedStr = reversedArr.join(<span class="string">&#x27;&#x27;</span>); <span class="comment">// 得到颠倒后的字符串</span></span><br><span class="line"><span class="built_in">console</span>.log(reversedStr); <span class="comment">// &#x27;emocleW&#x27;</span></span><br></pre></td></tr></table></figure>

<p>根据上面的思路，先将字符串 <code>&quot;Let&#39;s take LeetCode contest&quot;</code> 分割成以单词为单位的数组，再把数组中每个单词分割成以字母为数组元素的数组并执行颠倒操作，将颠倒后的数组拼接为字符串，这时得到了颠倒后的单词。最后，将单词拼接为字符串，便得到了颠倒后的字符串 <code>&quot;s&#39;teL ekat edoCteeL tsetnoc&quot;</code>。实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@file </span>reverseWords.js</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;Let&#x27;s take LeetCode contest&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> reversedArr = str.split(<span class="string">&#x27; &#x27;</span>).map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> item.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> result = reversedArr.join(<span class="string">&#x27; &#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>为了验证输出是否符合预期，使用测试工具 Jest 来验证：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@file </span>reverseWords.test.js</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> reverseWords <span class="keyword">from</span> <span class="string">&#x27;./reverseWords&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;Let&#x27;s take LeetCode contest&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> reversedStr = <span class="string">&quot;s&#x27;teL ekat edoCteeL tsetnoc&quot;</span>;</span><br><span class="line">test(<span class="string">`reverseWords: <span class="subst">$&#123;str&#125;</span>`</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  expect(str).toBe(reversedStr);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>使用 jest [file] 验证要测试的文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jest ./reverseWords.test.js</span></span><br><span class="line"> PASS  ./reverseWrods.test.ts</span><br><span class="line">  ✓ reverseWords: Let&#x27;s take LeetCode contest (3ms)</span><br><span class="line"></span><br><span class="line">Test Suites: 1 passed, 1 total</span><br><span class="line">Tests:       1 passed, 1 total</span><br><span class="line">Snapshots:   0 total</span><br><span class="line">Time:        1.089s</span><br><span class="line">Ran all test suites matching /.\/reverseWrods.test.ts/i.</span><br></pre></td></tr></table></figure>

<h2 id="出处"><a href="#出处" class="headerlink" title="出处"></a>出处</h2><p>来源：<a href="https://leetcode-cn.com/">力扣（LeetCode）</a><br>链接：<a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/">557. 反转字符串中的单词 III</a></p>
<div class="post-ggad"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-6487844781006261" data-ad-slot="3432081921"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>在 vscode 中离线安装扩展的方法</title>
    <url>/post/%E5%9C%A8-vscode-%E4%B8%AD%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E6%89%A9%E5%B1%95%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>明明可以在线安装 vscode 扩展，为什么要使用离线的方式安装呢？在线安装它不香嘛～</p>
<p>在线安装虽然香，但是遇到下面这种情况，它就香不起来啦。</p>
<span id="more"></span>

<p>现在许多企业把本地的开发环境搞到了云端，既能保证开发环境的一致性还能为开发人员提供强大的硬件性能。同时，为了项目安全性考虑，云端的开发环境是没有办法上网的，这种情况下怎么使用 vsocde 提供的扩展呢？下面手把手教你如何在离线环境下安装 vscode 插件。</p>
<h2 id="到-vscode-插件市场下载需要的扩展"><a href="#到-vscode-插件市场下载需要的扩展" class="headerlink" title="到 vscode 插件市场下载需要的扩展"></a>到 vscode 插件市场下载需要的扩展</h2><p>下面我们以安装简体中文语言包为例。访问 vscode 插件市场（<a href="https://marketplace.visualstudio.com/">https://marketplace.visualstudio.com</a>），搜索 chinese 找到我们需要的简体中文语言包。</p>
<p><img src="/images/2020/04/vscode_%E6%8F%92%E4%BB%B6%E5%B8%82%E5%9C%BA.png" alt="VSCode 插件市场"></p>
<p>上面红框中的结果就是我们要的简体中文语言包扩展文件。点进去，在页面右侧有一个 <strong>Download Extension</strong> 按钮，点击这里下载中文语言包文件。</p>
<p><img src="/images/2020/04/%E4%B8%8B%E8%BD%BDvscode%E4%B8%AD%E6%96%87%E8%AF%AD%E8%A8%80%E5%8C%85.webp" alt="简体中文语言包"></p>
<p>确认下载的文件是否是以 .vsix 为扩展的文件。</p>
<p><img src="/images/2020/04/vscode%E6%8F%92%E4%BB%B6%E6%89%A9%E5%B1%95%E6%96%87%E4%BB%B6%E4%B8%BA.vsix.png" alt="扩展文件"></p>
<h2 id="离线安装扩展"><a href="#离线安装扩展" class="headerlink" title="离线安装扩展"></a>离线安装扩展</h2><p>将扩展文件放到 vscode 安装目录下的 bin 目录。windows 下的 bin 目录很好找，在 vscode 安装目录下一眼就可以找到：</p>
<p><img src="/images/2020/04/vscode%E5%9C%A8windows%E4%B8%8B%E7%9A%84bin%E7%9B%AE%E5%BD%95%E4%BD%8D%E7%BD%AE.png" alt="Windows 下 bin 目录位置"></p>
<p>对于 mac 用户来说，要找到 bin 目录要稍微麻烦一点。打开 Finder，找到 vscode 应用程序，双指轻按触控板，选择弹出框的 <strong>显示包内容</strong> 选项。</p>
<p><img src="/images/2020/04/mac%E4%B8%8B%E6%98%BE%E7%A4%BAvscode%E7%9A%84%E5%8C%85%E5%86%85%E5%AE%B9.png" alt="Mac 下显示包内容"></p>
<p>依次打开 Contents -&gt; Resources -&gt; app 即可找到 bin 目录：</p>
<p><img src="/images/2020/04/mac%E4%B8%8B%E7%9A%84vscode%E7%9A%84bin%E7%9B%AE%E5%BD%95.png" alt="Mac 下 bin 目录位置"></p>
<p>我们看到 bin 目录下有一个名为 code 的可执行文件，我们需要在命令行工具中执行这个可执行文件。随便找个命令行工具，比如 windows 的 cmd 或者 mac 的 item 都可以，在命令行工具中 cd 到 bin 目录：</p>
<p><img src="/images/2020/04/cd%E5%88%B0vscode%E4%B8%AD%E7%9A%84bin%E7%9B%AE%E5%BD%95%E4%B8%8B.png" alt="终端执行命令"></p>
<p>在命令行中执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">code --install-extension ./MS-CEINTL.vscode-language-pack-zh-hans-1.46.0.vsix</span><br></pre></td></tr></table></figure>

<p>到这里我们就成功安装上简体中文离线扩展包文件啦～ 安装其他扩展也是同样的步骤。遇到任何问题欢迎在下方留言讨论哦 ^_^</p>
<div class="post-ggad"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-6487844781006261" data-ad-slot="3432081921"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div>]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>用 Github Actions 自动部署 Hexo 博客</title>
    <url>/post/%E7%94%A8-Github-Actions-%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2-Hexo-%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在配置 Hexo 和写博客的过程中，每次发布博客都要提交变更、hexo clean 和 hexo depoly，步骤实在是太繁琐。有没有一种方式可以实现自动化地部署博客呢？答案是有的。当前市面上有关自动化部署的工具确实不少，像常用的 jinkens、travis、circleci 和 GitHub Actions 等。</p>
<p>这里我就用 GitHub Actions 吧，毕竟博客是托管在 GitHub 上的，一套流程走下来也是方便的很。</p>
<span id="more"></span>

<h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><p>首先我们需要确保在本地已经安装了 hexo-cli，安装方式参见 <a href="https://hexo.io/zh-cn/docs/">官网</a>。</p>
<p>其次，我们要在 GitHub 上部署 pages，参考 <a href="https://pages.github.com/">这里</a>。</p>
<p>打开 Hexo 的配置文件 <code>_config.yml</code>，确保配置文件中有以下配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">git@github.com:smpower/smpower.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>

<p>这里解释一下，上面配置的意思是使用 <code>hexo-deployer-git</code> 插件将 Hexo 生成的静态网站资源提交到 <code>repository</code> 仓库的 <code>master</code> 分支上。当我们访问博客的时候，实际上就是访问的这个分支的静态资源。</p>
<div class="note info"><p>注意：请将 <code>repository</code> 改为你自己的仓库地址，并且将 <code>branch</code> 修改为你的 gh-pages 分支。</p>
</div>

<h2 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h2><p>这里我们生成的密钥是用在仓库中的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">&quot;Hexo Deploy Key&quot;</span> -f github-deploy-key-hi-ruofei-com -N <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>这会在当前目录下生成两个文件：</p>
<ul>
<li>github-deploy-key-hi-ruofei-com —— 私钥</li>
<li>github-deploy-key-hi-ruofei-com.pub —— 公钥</li>
</ul>
<h2 id="Github-配置密钥"><a href="#Github-配置密钥" class="headerlink" title="Github 配置密钥"></a>Github 配置密钥</h2><p>我们把 <code>私钥</code> 放在我们存放 Hexo 原始文件代码的仓库里面，用来触发 Actions 使用。</p>
<p>把 <code>公钥</code> 放在 GitHub pages 对应的仓库里面，用于 Hexo 部署时的写入操作。</p>
<h3 id="配置私钥"><a href="#配置私钥" class="headerlink" title="配置私钥"></a>配置私钥</h3><p>首先在 GitHub 上打开保存 Hexo 原始代码的仓库，访问 <code>Settings -&gt; Secrets</code>，页面如下：</p>
<p><img src="/images/2020/11/secrets.png"></p>
<p>然后点击 <code>New repository secret</code>:</p>
<p><img src="/images/2020/11/secrets2.png"></p>
<p><code>Name</code> 处填写 <code>HEXO_DEPLOY_KEY_HI_RUOFEI_COM</code>，注意大小写，这个后面的 GitHub Actions Workflow 要用到，一定不能写错。</p>
<p>在 <code>Value</code> 处填写 <code>github-deploy-key-hi-ruofei-com</code> 中的内容：</p>
<p><img src="/images/2020/11/new_secret.png"><br>添加了私钥以后的页面如下：</p>
<p><img src="/images/2020/11/secrets3.png"></p>
<h3 id="配置公钥"><a href="#配置公钥" class="headerlink" title="配置公钥"></a>配置公钥</h3><p>接下来我们需要访问存放网页的仓库，也就是 Hexo 部署以后的仓库，比如：yourname.github.io 这种，访问 Settings -&gt; Deploy keys：</p>
<p><img src="/images/2020/11/deploy_keys.png"></p>
<p>点击 <code>Add deploy key</code> 按钮来添加一个新的公钥：</p>
<p><img src="/images/2020/11/add_new_deploy_key.png"></p>
<p>在 Title 中输入：HEXO_DEPLOY_PUB_HI_RUOFEI_COM 字样，当然也可以填写其它自定义的名字。</p>
<p>在 Key 中粘贴 github-deploy-key-hi-ruofei-com.pub 文件的内容。</p>
<div class="note info"><p>注意：一定要勾选 Allow write access 来打开写权限，否则无法写入会导致部署失败。</p>
</div>

<p><img src="/images/2020/11/add_new_deploy_key2.png"></p>
<p>最后添加好了公钥的界面如下：</p>
<p><img src="/images/2020/11/deploy_keys2.png"></p>
<h2 id="创建-Workflow"><a href="#创建-Workflow" class="headerlink" title="创建 Workflow"></a>创建 Workflow</h2><p>首先在 Hexo 的仓库中创建一个新文件：.github&#x2F;workflows&#x2F;deploy.yml，文件名可以自己取，但是一定要放在 .github&#x2F;workflows 目录中，文件的内容如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Hexo</span> <span class="string">Deploy</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-18.04</span></span><br><span class="line">    <span class="attr">if:</span> <span class="string">github.event.repository.owner.id</span> <span class="string">==</span> <span class="string">github.event.sender.id</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">source</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">ref:</span> <span class="string">hexo</span> <span class="comment"># 这是你的 Hexo 源文件所在的分支</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Node.js</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">&quot;14.x&quot;</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Hexo</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">ACTION_DEPLOY_KEY:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.HEXO_DEPLOY_KEY_HI_RUOFEI_COM</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          mkdir -p ~/.ssh/</span></span><br><span class="line"><span class="string">          echo &quot;$ACTION_DEPLOY_KEY&quot; &gt; ~/.ssh/id_rsa</span></span><br><span class="line"><span class="string">          chmod 700 ~/.ssh</span></span><br><span class="line"><span class="string">          chmod 600 ~/.ssh/id_rsa</span></span><br><span class="line"><span class="string">          ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts</span></span><br><span class="line"><span class="string">          git config --global user.email &quot;contact@mail.ruofei.site&quot;</span></span><br><span class="line"><span class="string">          git config --global user.name &quot;ruofei&quot;</span></span><br><span class="line"><span class="string">          npm install hexo-cli yarn -g</span></span><br><span class="line"><span class="string">          yarn</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          hexo clean</span></span><br><span class="line"><span class="string">          hexo deploy</span></span><br></pre></td></tr></table></figure>

<p>简单解释一下，当我们推送内容到远程 hexo 分支的时候，就会触发这个 Workflow。</p>
<p>使用 Ubuntu 18.04 作为 hexo deploy 的系统。</p>
<p>首先 checkout 源代码(在 hexo 分支)，然后设置使用最新的 Node.js v14.x LTS 作为 node 解释器。</p>
<p>接下来就是创建 SSH 相关的配置文件，注意 secrets.HEXO_DEPLOY_KEY_HI_RUOFEI_COM 就是对应我们之前设置的私钥，所以名字一定不要搞错。</p>
<p>git config 相关的名字和邮件地址替换成大家自己使用的就好了。</p>
<p>最后就是安装 Hexo CLI，各个依赖模块和部署了。</p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>下面就是 GitHub Actions 页面显示的运行结果：</p>
<p><img src="/images/2020/11/workflows.png"></p>
<p>前面有绿色钩钩的，就表示部署成功，红色叉叉的表示失败。如果部署失败，还会收到 GitHub 的邮件提醒。</p>
<p>好了，以上就是利用 GitHub Actions 自动部署 Hexo 到 GitHub Pages 的方法，有疑问的请在下方留言哦 😊</p>
<div class="post-ggad"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-6487844781006261" data-ad-slot="3432081921"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div>]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack 基本配置</title>
    <url>/post/Webpack-%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="初始化项目目录"><a href="#初始化项目目录" class="headerlink" title="初始化项目目录"></a>初始化项目目录</h2><p>首先我们创建一个目录，初始化 npm，然后在本地安装 webpack，接着安装 <code>webpack-cli</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir webpack-demo</span><br><span class="line"><span class="built_in">cd</span> webpack-demo</span><br><span class="line">npm init -y</span><br><span class="line">npm install webpack webpack-cli html-webpack-plugin --save-dev <span class="comment"># 或 yarn add --dev webpack webpack-cli html-webpack-plugin</span></span><br></pre></td></tr></table></figure>

<div class="note info"><p><code>webpack-cli</code> 工具用于在命令行中运行 webpack。<a href="/development/webpack/plugins/HtmlWebpackPlugin"><code>html-webpack-plugin</code></a> 是 webpack 的一个自动生成 HTML5 文件的插件。</p>
</div>

<span id="more"></span>

<p>现在，我们将创建以下目录结构、文件和内容：</p>
<div class="tabs" id="初始化项目目录"><ul class="nav-tabs"><li class="tab active"><a href="#初始化项目目录-1">project</a></li><li class="tab"><a href="#初始化项目目录-2">package.json</a></li><li class="tab"><a href="#初始化项目目录-3">public/index.html</a></li><li class="tab"><a href="#初始化项目目录-4">src/index.js</a></li></ul><div class="tab-content"><div class="tab-pane active" id="初始化项目目录-1"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">webpack-demo</span><br><span class="line">|- package.json</span><br><span class="line">|- config/</span><br><span class="line">  |- webpack.config.js</span><br><span class="line">|- public/</span><br><span class="line">  |- index.html</span><br><span class="line">|- src/</span><br><span class="line">  |- index.js</span><br></pre></td></tr></table></figure>

<p>这是我们的项目目录结构。</p></div><div class="tab-pane" id="初始化项目目录-2"><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;webpack-demo&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.1.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;Webpack demo&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;webpack --config config/webpack.config.js&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;keywords&quot;</span>: [],</span><br><span class="line">  <span class="attr">&quot;author&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;license&quot;</span>: <span class="string">&quot;ISC&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;html-webpack-plugin&quot;</span>: <span class="string">&quot;^4.5.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;webpack&quot;</span>: <span class="string">&quot;^5.10.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;webpack-cli&quot;</span>: <span class="string">&quot;^4.2.0&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在命令行执行 <code>npm run build</code> 或 <code>yarn build</code> 命令时，webpack 会使用 config 目录下的 <code>webpack.config.js</code> 配置文件中的配置项来编译项目。</p></div><div class="tab-pane" id="初始化项目目录-3"><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Webpack demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    Hello world.</span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>该文件为模板文件，当 webpack 编译后会把该文件复制到 webpack 配置的输出目录中。</p></div><div class="tab-pane" id="初始化项目目录-4"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;Hello world.&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这就是我们项目的入口文件了。</p></div></div></div>

<h2 id="Webpack-基本配置"><a href="#Webpack-基本配置" class="headerlink" title="Webpack 基本配置"></a>Webpack 基本配置</h2><p>在 config 目录下的 webpack.config.js 文件中填写以下内容：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: path.resolve(__dirname, <span class="string">&quot;../src/index.js&quot;</span>),</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;main.js&quot;</span>,</span><br><span class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&quot;../dist&quot;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      <span class="attr">template</span>: path.resolve(__dirname, <span class="string">&quot;../public/index.html&quot;</span>),</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>entry</code>：webpack 的<a href="https://webpack.docschina.org/concepts/entry-points/">入口起点</a>，这里我们将 src 目录下的 index.js 文件作为入口起点。</li>
<li><code>output</code>： webpack 编译后的<a href="https://webpack.docschina.org/concepts/output/">输出目录</a>，最后编译后的文件将会输出到项目根目录的 dist 文件夹下。</li>
<li><code>plugins</code>：配置<a href="https://webpack.docschina.org/concepts/#plugins">插件</a>，可以配置任意多个插件。我们在这里配置了 <a href="/development/webpack/plugins/HtmlWebpackPlugin/">HtmlWebpackPlugin</a> 插件。该插件会通过配置项中的 <code>template</code> 属性将 public&#x2F;index.html 文件复制到 dist 目录下，并将 webpack 编译生成的 bundle 插入到文件中。</li>
</ul>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>执行 <code>npm run build</code> 或 <code>yarn build</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm run build</span><br><span class="line">[webpack-cli] Compilation finished</span><br><span class="line">asset index.html 225 bytes [emitted]</span><br><span class="line">asset main.js 28 bytes [compared <span class="keyword">for</span> emit] [minimized] (name: main)</span><br><span class="line">./src/index.js 29 bytes [built] [code generated]</span><br><span class="line">webpack 5.10.1 compiled successfully <span class="keyword">in</span> 259 ms</span><br><span class="line">✨  Done <span class="keyword">in</span> 1.38s.</span><br></pre></td></tr></table></figure>

<p>编译结束后，项目根目录项会被创建出一个 dist 目录，目录结构应该是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dist/</span><br><span class="line">|- index.html</span><br><span class="line">|- main.js</span><br></pre></td></tr></table></figure>

<p>在 index.html 的 <code>body</code> 标签中，我们会发现 main.js 文件已经被正确引入进来了。现在我们用浏览器打开 index.html 文件，会在页面中显示 <code>Hello world.</code> 且控制台中会打印 <code>Hello world.</code> 消息。</p>
<p>至此，一个最基本的 webpack 配置已经完成，有任何想法或疑问欢迎在下方留言讨论。</p>
<div class="post-ggad"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-6487844781006261" data-ad-slot="3432081921"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div>]]></content>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>typescript 中的联合类型和类型保护</title>
    <url>/post/typescript-%E4%B8%AD%E7%9A%84%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%B1%BB%E5%9E%8B%E4%BF%9D%E6%8A%A4/</url>
    <content><![CDATA[<p>下面通过一个简单的例子来说明 typescript 中的联合类型。</p>
<p>先来两只小动物：Bird 和 Dog。我们都知道，小鸟会叫、会飞，小狗会叫但是不会飞，根据它们的这两种属性我们就能定义两个接口，如下：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Bird &#123;</span><br><span class="line">  <span class="attr">fly</span>: <span class="built_in">boolean</span>;</span><br><span class="line">  sing: <span class="function">() =&gt;</span> &#123;&#125;; <span class="comment">// 小鸟唱歌</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Dog &#123;</span><br><span class="line">  <span class="attr">fly</span>: <span class="built_in">boolean</span>;</span><br><span class="line">  bark: <span class="function">() =&gt;</span> &#123;&#125;; <span class="comment">// 小狗汪汪叫</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>定义好了接口，那我们就来训练一下这两只小动物吧。下面我们定义一个函数 <code>trainAnimal</code>，该函数接收一个形参 <code>animal</code>，如果这个参数可以指 <code>Bird</code> 也可以指 <code>Dog</code>，那么我们可以这样写：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">animal: Bird | Dog</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>像上面函数中使用 <code>|</code> 将接口名分割开的写法就是 typescript 中联合类型的写法，联合类型允许我们将多个类型组合起来。在这个列子中 <code>animal</code> 可以是 <code>Bird</code> 和 <code>Dog</code> 两种类型中的任意一种。就像现实世界中我们所说的动物，小鸟和小狗都属于动物的一种。这样理解联合类型是不是就清楚多了呢？</p>
<p>类型 <code>Bird</code> 和 <code>Dog</code> 中都有 <code>fly</code> 属性，所以我们能很方便的访问到它们共有的这个属性 <code>fly</code>，但是其中的 <code>sing</code> 方法或 <code>bark</code> 方法就不能直接访问了。因为 <code>animal</code> 可能是 <code>Bird</code> 也可能是 <code>Dog</code>，如果 <code>animal</code> 是 <code>Bird</code> 的话肯定没有 <code>bark</code> 方法，如果 <code>animal</code> 是 <code>Dog</code> 的话，那肯定就没有 <code>sing</code> 方法了。那么我们该如何断定 <code>animal</code> 属于哪种类型呢？</p>
<p>下面有请<strong>类型断言</strong>上场。这家伙有个特点：我说是啥就是啥！不是也得是！</p>
<p>类型断言说：如果你会飞，你就是小鸟；如果不会飞，那你就是小狗！</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">animal: Bird | Dog</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (animal.fly) &#123;</span><br><span class="line">    (animal <span class="keyword">as</span> Bird).sing();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    (animal <span class="keyword">as</span> Dog).bark();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到 <code>as</code> 语法了吗？通常我们在 <code>as</code> 后接一个类型名，就表示 <code>as</code> 前的变量属于 <code>as</code> 后的类型，然后再以小括号包围起来。这个例子中，如果 <code>animal</code> 中 <code>fly</code> 属性为真的话，<code>animal</code> 指的就是 <code>Bird</code> 类型，然后就能访问到 <code>Bird</code> 中的 <code>sing</code> 方法了；反之，<code>animal</code> 就是 <code>Dog</code> 类型，这样就能访问到 <code>Dog</code> 类型中的 <code>bark</code> 方法了。</p>
<p>上面提到的<strong>类型断言</strong>是类型保护的一种方法，除此之外还有许多其他方式也可以实现类型保护的能力。比如使用 <code>in</code> 语法。</p>
<p><code>in</code> 语法要比上面的类型断言方式简单多了，不用我们额外判断方法传入的参数中是否存在 <code>fly</code> 属性。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trainAnimal</span>(<span class="params">animal: Bird | Dog</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&quot;sing&quot;</span> <span class="keyword">in</span> animal) animal.sing();</span><br><span class="line">  <span class="keyword">else</span> animal.bark();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码的意思是，我们利用 <code>in</code> 语法直接判断 <code>animal</code> 属性中是否存在 <code>sing</code> 属性，如果存在就直接调用 <code>sing</code> 方法。因为 <code>animal</code> 属性除了是 <code>Bird</code> 类型外，只可能是 <code>Dog</code> 类型，所以我们可以在 <code>if</code> 语句的 <code>else</code> 分支中直接调用 <code>bark</code> 方法。</p>
<p>通过这个简单的例子，我们就知道什么是联合类型和类型保护了吧。</p>
<div class="post-ggad"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-6487844781006261" data-ad-slot="3432081921"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div>]]></content>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 基础语法</title>
    <url>/post/JavaScript-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>ECMAScript 的语法大量借鉴了 C 及其他类 C 语言（如 Java 和 Perl）的语法，而 ECMAScript 语法相对其他语言的语法要更加宽松。</p>
<span id="more"></span>

<h2 id="区分大小写"><a href="#区分大小写" class="headerlink" title="区分大小写"></a>区分大小写</h2><p>ECMAScript 中的一切（变量、函数名和操作符）都区分大小写。比如，变量名 <code>test</code> 和变量名 <code>Test</code> 分别表示完全不同的两个变量。再比如，<code>typeof</code> 不能作为变量名（因为它是 ECMAScript 中的一个关键字，关键字不能用作函数名），但是 <code>typeOf</code> 则完全可以是一个有效的函数名。</p>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p><strong>标识符</strong>是指变量、函数、属性的名字，或者函数的参数。书写标识符有以下规则：</p>
<ul>
<li>第一个字符必须是一个字母、下划线（<code>_</code>）或一个美元符号（<code>$</code>）；</li>
<li>除第一个字符外的其他字符可以是字母、下划线、美元符号或数字。</li>
</ul>
<p>按照惯例，书写标识符应采用驼峰大小写格式。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">myHouse;</span><br><span class="line">doSomething;</span><br><span class="line">firstNumber;</span><br></pre></td></tr></table></figure>

<div class="note info"><p>不能把关键字、保留字、<code>true</code>、<code>false</code> 和 <code>null</code> 用作标识符。</p>
</div>

<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>ECMAScript 中有两风格的注释，分别是单行注释和块级注释。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单行注释</span></span><br></pre></td></tr></table></figure>

<p>块级注释以一个斜杠和一个星号（<code>/*</code>）开头，以一个星号和一个斜杠（<code>*/</code>）结尾。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 多行注释</span></span><br><span class="line"><span class="comment"> * （块级）注释</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>第二行和第三行开始的星号不是必须的，这样写纯粹是为了提高注释的可读性。</p>
<h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><p>要在脚本中启用严格模式，可以在文件顶部添加以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>除此以外，还可以在函数内部启用严格模式，指示该函数在严格模式下运行：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &quot;use strict&quot;</span>;</span><br><span class="line">  <span class="comment">// do something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p>ECMAScript 中的语句以一个英文分号（<code>;</code>）结尾；若省略分号，则由解析器确定语句的结尾。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = a + b; <span class="comment">// 没有分号也不要紧，但是不推荐这样的写法</span></span><br><span class="line"><span class="keyword">const</span> diff = a - b; <span class="comment">// 推荐每条语句后都要写分号</span></span><br></pre></td></tr></table></figure>

<div class="post-ggad"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-6487844781006261" data-ad-slot="3432081921"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript 语法</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 实现 Base-64 编码解码</title>
    <url>/post/JavaScript-%E5%AE%9E%E7%8E%B0-Base-64-%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81/</url>
    <content><![CDATA[<p>目前绝大多数浏览器已原生支持 Base-64 的编码解码（最低支持到 IE10），详细的浏览器兼容性列表请参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WindowBase64/btoa#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7">这里</a>。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>最常见的是对 Image 对象进行 Base-64 的编码解码。其次，我们也可以用于传输数据时的 Base-64 编码解码，比如浏览器地址栏中的参数可能在传输数据过程中出现的问题。</p>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ul>
<li><code>window.btoa()</code></li>
<li><code>window.atob()</code></li>
</ul>
<span id="more"></span>

<p><code>window.btoa()</code> 从 <code>String</code> 对象中创建一个 Base-64 编码的 ASCII 字符串，其中字符串中的每个字符都被视为一个二进制数据字节。<code>atob()</code> 方法可以将通过 <code>window.btoa()</code> 编码的字符串数据解码。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight javascript"><figcaption><span>window.btoa()</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> encodedData = <span class="built_in">window</span>.btoa(stringToEncode); <span class="comment">// 对数据进行编码</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><figcaption><span>window.atob()</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> decodedData = <span class="built_in">window</span>.atob(encodedData); <span class="comment">// 对数据进行解码</span></span><br></pre></td></tr></table></figure>

<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul>
<li><p><code>window.btoa(stringToEncode)</code></p>
<p><code>stringToEncode</code> - 一个字符串，其字符分别表示要编码为 ASCII 的二进制数据的单个字节。</p>
</li>
<li><p><code>window.atob(encodedData)</code></p>
<p><code>encodedData</code> - 一个 Base-64 表示的字符串。</p>
</li>
</ul>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><ul>
<li><p><code>window.btoa(stringToEncode)</code></p>
<p>一个包含 <code>stringToEncode</code> 的 Base-64 表示的字符串。</p>
</li>
<li><p><code>window.atob(encodedData)</code></p>
<p>对 Base-64 字符串解码后的 <code>String</code> 对象。</p>
</li>
</ul>
<h2 id="Unicode-字符串"><a href="#Unicode-字符串" class="headerlink" title="Unicode 字符串"></a>Unicode 字符串</h2><p>在多数浏览器中，使用 <code>btoa()</code> 对 Unicode 字符串进行编码都会触发 <code>InvalidCharacterError</code> 异常。可以考虑下面这个例子，代码来自<a href="http://ecmanaut.blogspot.com/2006/07/encoding-decoding-utf8-in-javascript.html">Johan Sundström</a>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ucs-2 string to base64 encoded ascii</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">utoa</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">window</span>.btoa(<span class="built_in">unescape</span>(<span class="built_in">encodeURIComponent</span>(str)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// base64 encoded ascii to ucs-2 string</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">atou</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">decodeURIComponent</span>(<span class="built_in">escape</span>(<span class="built_in">window</span>.atob(str)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Usage:</span></span><br><span class="line">utoa(<span class="string">&quot;✓ à la mode&quot;</span>); <span class="comment">// 4pyTIMOgIGxhIG1vZGU=</span></span><br><span class="line">atou(<span class="string">&quot;4pyTIMOgIGxhIG1vZGU=&quot;</span>); <span class="comment">// &quot;✓ à la mode&quot;</span></span><br><span class="line"></span><br><span class="line">utoa(<span class="string">&quot;I \u2661 Unicode!&quot;</span>); <span class="comment">// SSDimaEgVW5pY29kZSE=</span></span><br><span class="line">atou(<span class="string">&quot;SSDimaEgVW5pY29kZSE=&quot;</span>); <span class="comment">// &quot;I ♡ Unicode!&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/sunwork888/article/details/89436947?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-6&spm=1001.2101.3001.4242">浏览器原生支持 JS Base64 编码解码</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WindowBase64/btoa">WindowOrWorkerGlobalScope.btoa()</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WindowBase64/atob">WindowOrWorkerGlobalScope.atob()</a></li>
</ul>
<div class="post-ggad"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-6487844781006261" data-ad-slot="3432081921"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>btoa</tag>
        <tag>atob</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack 插件之 HtmlWebpackPlugin</title>
    <url>/post/Webpack-%E6%8F%92%E4%BB%B6%E4%B9%8B-HtmlWebpackPlugin/</url>
    <content><![CDATA[<p>该插件将为你生成一个 HTML5 文件，用以服务 webpack 编译输出的 bundle。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save-dev html-webpack-plugin <span class="comment"># or yarn add --dev html-webpack-plugin</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h2><p>该插件会为你生成一个 HTML5 文件，在文件的 <code>body</code> 标签中包含 webpack 编译输出的所有 bundle 文件。你只需要在 webpack 配置文件中启用该插件即可：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&quot;index.js&quot;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&quot;./dist&quot;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;index_bundle.js&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="keyword">new</span> HtmlWebpackPlugin()],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>webpack 编译后会在 dist 目录下创建一个 index.html 文件，文件中将包含以下内容：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>webpack App<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;index_bundle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>要查看该插件所有配置项，参考<a href="https://github.com/jantimon/html-webpack-plugin#plugins">插件文档</a>。</p>
<div class="post-ggad"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-6487844781006261" data-ad-slot="3432081921"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div>]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title>安装 Node.js</title>
    <url>/post/%E5%AE%89%E8%A3%85-Node-js/</url>
    <content><![CDATA[<h2 id="通过软件包安装-Node-js"><a href="#通过软件包安装-Node-js" class="headerlink" title="通过软件包安装 Node.js"></a>通过软件包安装 Node.js</h2><p>这是最简单的安装方式，通过下载官网编译好的软件包，可直接在本地计算机中安装 Node.js。要下载各平台支持的软件包，请访问<a href="https://nodejs.org/en/download/">这里</a>。</p>
<span id="more"></span>

<h2 id="通过包管理器安装-Node-js"><a href="#通过包管理器安装-Node-js" class="headerlink" title="通过包管理器安装 Node.js"></a>通过包管理器安装 Node.js</h2><p>另一种便捷的方式是通过软件包管理器安装 Node.js。每种操作系统都有其自身的包管理器，适用与 Linux 和 windows 的包管理器列出在 <a href="https://nodejs.org/en/download/package-manager/">https://nodejs.org/en/download/package-manager/</a>。</p>
<p>在 MacOS 上，可通过 Homebrew 安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install node</span><br></pre></td></tr></table></figure>

<div class="note info"><p>安装 Homebrew 总是失败怎么办？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/bin/zsh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>在中国大陆使用这个仓库安装 Homebrew 会非常快，该仓库会每天从 GitHub 同步一次，可放心使用。</p>
</div>

<h2 id="通过-nvm-安装-Node-js"><a href="#通过-nvm-安装-Node-js" class="headerlink" title="通过 nvm 安装 Node.js"></a>通过 nvm 安装 Node.js</h2><p>nvm 是一种流行的运行 Node.js 的方式，使用 nvm 可轻松地切换 Node.js 版本。nvm 的安装使用请参考<a href="https://github.com/nvm-sh/nvm#installing-and-updating">说明文档</a>。</p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>无论哪种方式，当安装 Node.js 之后，就可以在命令行中访问 <code>node</code> 可执行程序和 <code>npm</code> 包管理器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ node -v</span><br><span class="line">v14.15.3</span><br><span class="line"></span><br><span class="line">$ npm -v</span><br><span class="line">6.14.9</span><br></pre></td></tr></table></figure>

<div class="post-ggad"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-6487844781006261" data-ad-slot="3432081921"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div>]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
  </entry>
  <entry>
    <title>理解 JavaScript 中的对象</title>
    <url>/post/%E7%90%86%E8%A7%A3-JavaScript-%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>通常，通过创建 <code>Object</code> 的一个实例来创建自定义对象，然后再给它添加属性和方法。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">person.name = <span class="string">&quot;Olive&quot;</span>;</span><br><span class="line">person.age = <span class="number">18</span>;</span><br><span class="line">person.gender = <span class="string">&quot;female&quot;</span>;</span><br><span class="line">person.job = <span class="string">&quot;Frontend Engineer&quot;</span>;</span><br><span class="line">person.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面这个例子创建了一个 <code>person</code> 对象，其中有四个属性（<code>name</code>、<code>age</code>、<code>gender</code> 和 <code>job</code>）和一个方法（<code>sayName()</code>）。<code>sayName()</code> 方法会在控制台打印 <code>this.name</code> 的值，这个属性会解析为 <code>person.name</code>。</p>
<p>除上面通过实例化 <code>Object</code> 的方式创建对象外，还可以通过对象字面量的方式创建 <code>person</code> 对象。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Olive&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">gender</span>: <span class="string">&quot;female&quot;</span>,</span><br><span class="line">  <span class="attr">job</span>: <span class="string">&quot;Frontend Engineer&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">sayName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个例子跟前面例子中的 <code>person</code> 对象是等价的，他们的属性和方法都一样。</p>
<span id="more"></span>

<h2 id="属性的类型"><a href="#属性的类型" class="headerlink" title="属性的类型"></a>属性的类型</h2><p>属性分两种：<strong>数据属性</strong>和<strong>访问器属性</strong>。</p>
<h3 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h3><p>数据属性包含一个保存数据值的位置。值会从这个位置读取，也会写入到这个位置。数据属性包含 4 个特性描述它们的行为。</p>
<ul>
<li><p><code>[[Configurable]]</code>：表示属性是否可以通过 <code>delete</code> 删除属性，是否可以修改它的特性，以及是否可以把它改为访问器属性。默认情况下，所有直接定义在对象上的属性的这个特性都是 <code>true</code>。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Olive&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">gender</span>: <span class="string">&quot;female&quot;</span>,</span><br><span class="line">  <span class="attr">job</span>: <span class="string">&quot;Frontend Engineer&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">sayName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">&quot;name&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">delete</span> person.name;</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// &#x27;Olive&#x27;</span></span><br></pre></td></tr></table></figure>

<p>修改了 <code>[[Configurable]]</code> 属性值为 <code>false</code> 后，就意味着不能通过 <code>delete</code> 删除对象上的属性。而 <code>[[Configurable]]</code> 属性值为 <code>true</code> 时，若删除了 <code>person</code> 对象上的 <code>name</code> 属性后，<code>person.name</code> 的值应为 <code>undefined</code>。</p>
<p>此外，对象上的一个属性被定义为不可配置后，就不能再变回可配置的了。再次调用 <code>Object.defineProperty()</code> 并修改任何非 <code>writable</code> 属性会导致错误。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Olive&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">gender</span>: <span class="string">&quot;female&quot;</span>,</span><br><span class="line">  <span class="attr">job</span>: <span class="string">&quot;Frontend Engineer&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">sayName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">&quot;name&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">&quot;name&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里会报错：</span></span><br><span class="line"><span class="comment"> * Uncaught TypeError: Cannot redefine property: name</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>因此，虽然可以对对象上的同一个属性多次调用 <code>Object.defineProperty()</code>，但当把 <code>configurable</code> 设置为 <code>false</code> 后就会受到限制。</p>
</li>
<li><p><code>[[Enumerable]]</code>：表示属性是否可以通过 <code>for-in</code> 循环返回。默认情况下，所有直接定义在对象上的属性的这个特性都是 <code>true</code>。以 <code>person</code> 对象为例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> person) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码通过 <code>for-in</code> 语句对 <code>person</code> 对象执行的遍历操作，会在控制台依次打印出如下结果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &quot;name&quot;</span></span><br><span class="line"><span class="comment"> * &quot;age&quot;</span></span><br><span class="line"><span class="comment"> * &quot;gender&quot;</span></span><br><span class="line"><span class="comment"> * &quot;job&quot;</span></span><br><span class="line"><span class="comment"> * &quot;sayName&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>当把 <code>person</code> 对象上的 <code>name</code> 属性的 <code>enumerable</code> 属性设置为 <code>false</code> 后，再使用 <code>for-in</code> 语句执行遍历操作时，控制台将不会打印出 <code>name</code> 属性。</p>
</li>
<li><p><code>[[Writable]]</code>：表示属性的值是否可以被修改。默认情况下，所有直接定义在对象上的属性的这个特性都是 <code>true</code>。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">person.name = <span class="string">&quot;Jack&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// &quot;Jack&quot;</span></span><br></pre></td></tr></table></figure>

<p>当对 <code>person.name</code> 重新赋值为 <code>Jack</code> 后，在控制台打印出的值为 <code>Jack</code>。若将 <code>person.name</code> 属性上的 <code>writable</code> 设置为 <code>false</code>，则不能对 <code>person.name</code> 属性执行重新赋值的操作。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Olive&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">gender</span>: <span class="string">&quot;female&quot;</span>,</span><br><span class="line">  <span class="attr">job</span>: <span class="string">&quot;Frontend Engineer&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">sayName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">&quot;name&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br><span class="line">person.name = <span class="string">&quot;Jack&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// &quot;Olive&quot;</span></span><br></pre></td></tr></table></figure>

<p>因把 <code>name</code> 属性的 <code>writable</code> 值设置为 <code>false</code>，当再次尝试修改 <code>person.name</code> 的值时，我们发现并没有生效，控制台中打印出的 <code>person.name</code> 的值依然是通过对象字面量定义时的值——<code>Olive</code>。</p>
</li>
<li><p><code>[[Value]]</code>：包含属性实际的值。默认情况下，所有直接定义在对象上的属性的这个特性都是 <code>true</code>。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Olive&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">gender</span>: <span class="string">&quot;female&quot;</span>,</span><br><span class="line">  <span class="attr">job</span>: <span class="string">&quot;Frontend Engineer&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">sayName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">&quot;name&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&quot;Jack&quot;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// &quot;Jack&quot;</span></span><br></pre></td></tr></table></figure>

<p>可以看到 <code>person.name</code> 属性值已被修改为 <code>Jack</code>。</p>
</li>
</ul>
<h3 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h3><p>访问器属性不包含数据值。它包含一个获取（getter）函数和一个设置（setter）函数，不过这两个函数不是必需的。在读取访问器属性时，会调用获取函数，该函数会返回一个有效值。在写入访问器属性时，会调用设置函数并传入新的值，该函数必须决定对数据做出什么修改。访问器属性有 4 个特性描述他们的行为。</p>
<ul>
<li><code>[[Configurable]]</code>：表示属性是否可以通过 <code>delete</code> 删除并重新定义，是否可以修改它的特性，以及是否可以把它改为数据属性。默认情况下，所有直接定义在对象上的属性的这个特性都是 <code>true</code>。</li>
<li><code>[[Enumerable]]</code>：表示属性是否可以通过 <code>for-in</code> 循环返回。默认情况下，所有直接定义在对象上的属性的这个特性都是 <code>true</code>。</li>
<li><code>[[Get]]</code>：获取函数，在读取属性时调用。默认值为 <code>undefined</code>。</li>
<li><code>[[Set]]</code>：设置函数，在设置属性时调用。默认值为 <code>undefined</code>。</li>
</ul>
<p>访问器属性不可直接定义，需通过 <code>Object.defineProperty()</code> 实现。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个对象，包含伪私有成员 `year_` 和公共成员 `edition`</span></span><br><span class="line"><span class="keyword">const</span> book = &#123;</span><br><span class="line">  <span class="attr">year_</span>: <span class="number">2017</span>,</span><br><span class="line">  <span class="attr">edition</span>: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(book, <span class="string">&quot;year&quot;</span>, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.year_;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">newValue</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (newValue &gt; <span class="number">2017</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.year_ = newValue;</span><br><span class="line">      <span class="built_in">this</span>.edition += newValue - <span class="number">2017</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">book.year = <span class="number">2018</span>;</span><br><span class="line"><span class="built_in">console</span>.log(book.edition); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>book</code> 对象有 2 个属性：<code>year_</code> 和 <code>edition</code>。<code>year_</code> 中的下划线通常表示不希望该属性在对象外部被访问。</p>
<p>另一个参数 <code>year</code> 被定义为一个访问器属性，其中获取函数（<code>get()</code>）简单地返回 <code>year_</code> 地值，而设置函数（<code>set()</code>）会根据传入的参数 <code>newValue</code> 做一些简单的判断来计算正确的 <code>edition</code> 值，同时把传入的参数赋值给私有属性 <code>year_</code>。</p>
<p>因此，把 <code>year</code> 属性修改为 2018 后会导致属性 <code>year_</code> 的值变为 2018，同时 <code>edition</code> 的值变为 2。这就是访问器属性的典型使用场景，即设置一个值会导致另外一些值发生变化。</p>
<p>这里要注意，在不支持 <code>Object.defineProperty()</code> 的浏览器中无法修改 <code>[[Configurable]]</code> 或 <code>[[Enumerable]]</code>。</p>
<h2 id="定义多个属性"><a href="#定义多个属性" class="headerlink" title="定义多个属性"></a>定义多个属性</h2><p>ECMAScript 提供了 <code>Object.defineProperties()</code> 方法允许在一个对象上同时定义多个属性。该方法可以通过多个描述符一次性定义多个属性。</p>
<p>它接收 2 个参数：要添加或修改属性的对象和另一个描述符对象，其属性与要添加或修改的属性一一对应。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> book = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(book, &#123;</span><br><span class="line">  <span class="attr">year_</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">2017</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">edition</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">year</span>: &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.year_;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">newValue</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (newValue &gt; <span class="number">2017</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.year_ = newValue;</span><br><span class="line">        <span class="built_in">this</span>.edition += newValue - <span class="number">2017</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这段代码在 <code>book</code> 对象上定义了 2 个数据属性：<code>year_</code> 和 <code>edition</code>，和 1 个访问器属性 <code>year</code>。该对象与之前的 <code>book</code> 对象是一样的。</p>
<p>唯一取表就是所有属性是同时定义的，并且数据属性的 <code>configurable</code>、<code>enumerable</code> 和 <code>writable</code> 特性值都为 <code>false</code>。因此，当给访问器属性 <code>year</code> 重新赋值并不会生效。想要对访问器属性 <code>year</code> 重新赋值后仍能更新私有成员 <code>year_</code> 和 <code>edition</code> 属性，应将对其属性对应的 <code>writable</code> 特性设置为 <code>true</code>。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> book = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(book, &#123;</span><br><span class="line">  <span class="attr">year_</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">2017</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">edition</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">year</span>: &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.year_;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">newValue</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (newValue &gt; <span class="number">2017</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.year_ = newValue;</span><br><span class="line">        <span class="built_in">this</span>.edition += newValue - <span class="number">2017</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">book.year = <span class="number">2020</span>;</span><br><span class="line"><span class="built_in">console</span>.log(book.edition); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<h2 id="读取属性的特性"><a href="#读取属性的特性" class="headerlink" title="读取属性的特性"></a>读取属性的特性</h2><p>使用 <code>Object.getOwnPropertyDescriptor()</code> 方法可以获取指定对象属性的属性描述符。该方法接收 2 个参数：属性所在的对象和要取得其描述符的属性名。返回值是一个对象，对于数据属性包含 <code>configurable</code>、<code>enumerable</code>、<code>writable</code> 和 <code>value</code> 属性。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> book = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(book, &#123;</span><br><span class="line">  <span class="attr">year_</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">2017</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">edition</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">year</span>: &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.year_;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (newValue &gt; <span class="number">2017</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.year_ = newValue;</span><br><span class="line">        <span class="built_in">this</span>.edition += newValue - <span class="number">2017</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> descriptorOfPrivateYear = <span class="built_in">Object</span>.getOwnPropertyDescriptor(book, <span class="string">&quot;year_&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(descriptor.value); <span class="comment">// 2017</span></span><br><span class="line"><span class="built_in">console</span>.log(descriptor.configurable); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> descriptor.get); <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> descriptorOfPublicYear = <span class="built_in">Object</span>.getOwnPropertyDescriptor(book, <span class="string">&quot;year&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(descriptor.value); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(descriptor.enumerable); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> descriptor.get); <span class="comment">// &quot;function&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面这个例子中：对于数据属性 <code>year_</code>，<code>value</code> 等于原来的值，<code>configurable</code>、<code>enumerable</code> 和 <code>writable</code> 是 <code>false</code>，<code>get</code> 和 <code>set</code> 方法是 <code>undefined</code>。对于访问器属性 <code>year</code>，<code>value</code> 是 <code>undefined</code>，<code>configurable</code> 和 <code>enumerable</code> 是 <code>false</code>，<code>get</code> 是一个指向获取函数的指针，<code>set</code> 是一个指向设置函数的指针。</p>
<p>静态方法 <code>Object.getOwnPropertyDescriptors()</code> ，会在对象的每个自有属性上调用 <code>Object.getOwnPropertyDescriptor()</code> 并在一个新对象中返回它们。在上面例子中使用这个静态方法，会返回如下对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> book = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(book, &#123;</span><br><span class="line">  <span class="attr">year_</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">2017</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">edition</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">year</span>: &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.year_;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (newValue &gt; <span class="number">2017</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.year_ = newValue;</span><br><span class="line">        <span class="built_in">this</span>.edition += newValue - <span class="number">2017</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptors(book));</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   year_: &#123;</span></span><br><span class="line"><span class="comment">//     value: 2017,</span></span><br><span class="line"><span class="comment">//     writable: false,</span></span><br><span class="line"><span class="comment">//     enumerable: false,</span></span><br><span class="line"><span class="comment">//     configurable: false</span></span><br><span class="line"><span class="comment">//   &#125;,</span></span><br><span class="line"><span class="comment">//   edition: &#123; value: 1, writable: false, enumerable: false, configurable: false &#125;,</span></span><br><span class="line"><span class="comment">//   year: &#123;</span></span><br><span class="line"><span class="comment">//     get: [Function: get],</span></span><br><span class="line"><span class="comment">//     set: [Function: set],</span></span><br><span class="line"><span class="comment">//     enumerable: false,</span></span><br><span class="line"><span class="comment">//     configurable: false</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="合并对象"><a href="#合并对象" class="headerlink" title="合并对象"></a>合并对象</h2><p>使用 <code>Object.assign()</code> 方法可以合并对象。该方法接收一个目标对象和一个或多个源对象作为参数，然后将每个源对象中可枚举和自有属性复制到目标对象。对每个符合条件的属性，这个方法会使用源对象上的 <code>[[Get]]</code> 获取其属性的值，使用目标对象的 <code>[[Set]]</code> 设置属性的值。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简单复制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> dest = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> src = &#123; <span class="attr">id</span>: <span class="string">&quot;src&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> result = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">result = <span class="built_in">Object</span>.assign(dest, src);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object.assign() 修改目标对象</span></span><br><span class="line"><span class="comment">// 也会返回修改后的对象</span></span><br><span class="line"><span class="built_in">console</span>.log(dest === result); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(dest !== src); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// &#123; id: &#x27;src&#x27; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(dest); <span class="comment">// &#123; id: &#x27;src&#x27; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多个源对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dest = &#123;&#125;;</span><br><span class="line">result = <span class="built_in">Object</span>.assign(dest, &#123; <span class="attr">name</span>: <span class="string">&quot;Olive&quot;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// &#123; name: &#x27;Olive&#x27;, age: 18 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取函数与设置函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dest = &#123;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">name</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Invoked dest setter with param <span class="subst">$&#123;val&#125;</span>`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">src = &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">name</span>() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Invoked src getter&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Olive&quot;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(dest, src);</span><br><span class="line"><span class="comment">// 调用 src 的获取方法</span></span><br><span class="line"><span class="comment">// 调用 dest 的设置方法并传入参数 `Olive`</span></span><br><span class="line"><span class="comment">// 因为这里的设置函数没有执行赋值操作</span></span><br><span class="line"><span class="comment">// 所以实际上并没有把值转移过来</span></span><br><span class="line"><span class="built_in">console</span>.log(dest);</span><br><span class="line"><span class="comment">// &#x27;Invoked src getter</span></span><br><span class="line"><span class="comment">// &#x27;Invoked dest setter with param foo&#x27;</span></span><br><span class="line"><span class="comment">// &#123; name: [Setter] &#125;</span></span><br></pre></td></tr></table></figure>

<p><code>Object.assign()</code> 方法实际上对每个源对象执行的是浅复制操作。如果多个源对象用于相同的属性，则使用最后一个赋值的值。</p>
<p>另外，从源对象<a href="./#%E8%AE%BF%E9%97%AE%E5%99%A8%E5%B1%9E%E6%80%A7">访问器属性</a>取得的值，比如获取函数，会作为一个静态值赋给目标对象。也就是说，不能在两个对象间转移获取函数和设置函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dest, src, result;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 覆盖属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dest = &#123; <span class="attr">id</span>: <span class="string">&quot;dest&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">result = <span class="built_in">Object</span>.assign(</span><br><span class="line">  dest,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&quot;src1&quot;</span>, <span class="attr">name</span>: <span class="string">&quot;Olive&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&quot;src2&quot;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object.assign 会覆盖重复的属性</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// &#123; id: &#x27;src2&#x27;, name: &#x27;Olive&#x27;, age: 18 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以通过目标对象上的设置函数观察到覆盖过程：</span></span><br><span class="line">dest = &#123;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">id</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(dest, &#123; <span class="attr">id</span>: <span class="string">&quot;first&quot;</span> &#125;, &#123; <span class="attr">id</span>: <span class="string">&quot;second&quot;</span> &#125;, &#123; <span class="attr">id</span>: <span class="string">&quot;third&quot;</span> &#125;);</span><br><span class="line"><span class="comment">// &#x27;first&#x27;</span></span><br><span class="line"><span class="comment">// &#x27;second&#x27;</span></span><br><span class="line"><span class="comment">// &#x27;third&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对象引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dest = &#123;&#125;;</span><br><span class="line">src = &#123;</span><br><span class="line">  <span class="attr">name</span>: &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(dest, src);</span><br><span class="line"><span class="comment">// 潜复制意味着只会复制对象的引用</span></span><br><span class="line"><span class="built_in">console</span>.log(dest); <span class="comment">// &#123; name: &#123;&#125; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(dest.name === src.name); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="对象标识和相等判断"><a href="#对象标识和相等判断" class="headerlink" title="对象标识和相等判断"></a>对象标识和相等判断</h2><p>有些特殊情况下，相等操作符 <code>===</code> 并不能符合我们的预期：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这些是 `===` 符合预期的情况</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> === <span class="number">1</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125; === &#123;&#125;); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;2&quot;</span> === <span class="number">2</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的情况在不同的 js 引擎中表现不同</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="number">0</span> === -<span class="number">0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="number">0</span> === <span class="number">0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(-<span class="number">0</span> === <span class="number">0</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 要确定 NaN 的相等性，必须要使用 `isNaN()`</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> === <span class="literal">NaN</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">NaN</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>为改善上述情况，ES6 规范新增了 <code>Object.is()</code> 方法，该方法接收 2 个参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="literal">true</span>, <span class="number">1</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(&#123;&#125;, &#123;&#125;)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="string">&quot;2&quot;</span>, <span class="number">2</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的 0、+0、-0 相等/不相等判定</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(+<span class="number">0</span>, -<span class="number">0</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">0</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(-<span class="number">0</span>, <span class="number">0</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的 `NaN` 相等性判定</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>要检查超过 2 个值，递归地利用相等性判断即可：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">recursivelyCheckEqual</span>(<span class="params">x, ...rest</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="built_in">Object</span>.is(x, rest[<span class="number">0</span>]) &amp;&amp; (rest.length &lt; <span class="number">2</span> || recursivelyCheckEqual(...rest))</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> first = <span class="string">&quot;Olive&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> second = <span class="string">&quot;Olive&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> third = <span class="string">&quot;Olive&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> fourth = <span class="string">&quot;Olive&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = recursivelyCheckEqual(first, second, third, fourth);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<div class="post-ggad"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-6487844781006261" data-ad-slot="3432081921"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript 中的对象、类和面向对象编程</tag>
      </tags>
  </entry>
  <entry>
    <title>React Hook 之封装 useArray 自定义 hook</title>
    <url>/post/React-Hook-%E4%B9%8B%E5%B0%81%E8%A3%85-useArray-%E8%87%AA%E5%AE%9A%E4%B9%89-hook/</url>
    <content><![CDATA[<p>在对数组操作时，我们经常要执行新增或删除数组元素的操作，将一些常用的数组操作封装成 React 自定义 hook 使用会非常方便。下面将封装一个自定义的 <code>useArray</code> React hook，实现数组的取值、设置值、添加、删除和清理数组的功能。</p>
<span id="more"></span>

<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * use-array.tsx</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 封装 useArray 自定义 React hook</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&#125;</span> </span>initialArray 要处理的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;Array&#125;</span> </span>Object.value 处理过后的数组元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;Function&#125;</span> </span>Object.setValue 更新数组的方法，该方法是 `useState()` 方法返回的用于更新 state 的函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;Function&#125;</span> </span>Object.add 向数组末尾添加元素的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;Function&#125;</span> </span>Object.clear 该方法会将传入的数组清空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;Function&#125;</span> </span>Object.removeIndex 该方法会将指定的数组元素从数组中移除</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useArray = <span class="function">(<span class="params">initialArray</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [value, setValue] = useState(initialArray);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    value,</span><br><span class="line">    setValue,</span><br><span class="line">    <span class="attr">add</span>: <span class="function">(<span class="params">item</span>) =&gt;</span> setValue([...value, item]),</span><br><span class="line">    <span class="attr">clear</span>: <span class="function">() =&gt;</span> setValue([]),</span><br><span class="line">    <span class="attr">removeIndex</span>: <span class="function">(<span class="params">index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> copy = [...value];</span><br><span class="line">      copy.splice(index, <span class="number">1</span>);</span><br><span class="line">      setValue(copy);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面封装的自定义 hook <code>useArray</code> 将返回一系列对处理数组有用的方法和值：</p>
<ul>
<li><code>value</code>：处理过后的数组元素。</li>
<li><code>setValue</code>：该方法是 <code>useState()</code> 方法返回的用于更新数组的方法。</li>
<li><code>add</code>：该方法接受一个任意值，允许用户向数组末尾添加一个新元素。</li>
<li><code>clear</code>：该方法会把传入的数组中的元素清空。</li>
<li><code>removeIndex</code>：该方法接受一个数组元素的下标，会将数组中对应该下标的元素从数组中移除。</li>
</ul>
<p>使用方法：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> useArray <span class="keyword">from</span> <span class="string">&quot;use-array&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> UserList = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// &#123; value, setValue, add, clear, removeIndex &#125; = useArray(initialArray);</span></span><br><span class="line">  <span class="keyword">const</span> &#123; value, add &#125; = useArray([</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&quot;Olive&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&quot;Jack&quot;</span> &#125;,</span><br><span class="line">  ]);</span><br><span class="line">  add(&#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">name</span>: <span class="string">&quot;Amy&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span>&#123;value ? <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;value.id&#125;</span>&gt;</span>&#123;value.name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span> : null&#125;<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> UserList;</span><br></pre></td></tr></table></figure>

<p>之后，根据业务场景可随时向 <code>useArray</code> 自定义 hook 中添加额外逻辑。一处添加，到处使用。</p>
<div class="post-ggad"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-6487844781006261" data-ad-slot="3432081921"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div>]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React Hooks</tag>
        <tag>React 钩子函数</tag>
        <tag>React 自定义 Hook</tag>
      </tags>
  </entry>
  <entry>
    <title>React Hook 之封装 useMount 自定义 hook</title>
    <url>/post/React-Hook-%E4%B9%8B%E5%B0%81%E8%A3%85-useMount-%E8%87%AA%E5%AE%9A%E4%B9%89-hook/</url>
    <content><![CDATA[<p>下面是一个使用 React 编写的函数式组件：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * user-list.jsx</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> UserList = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [users, setUsers] = useState([]);</span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    fetch(<span class="string">&#x27;/users&#x27;</span>).then(<span class="keyword">async</span> response =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (response.ok) &#123;</span><br><span class="line">        setUsers(<span class="keyword">await</span> response.json());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// do something...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;users ? users.map((user) =&gt; (</span></span><br><span class="line"><span class="xml">         <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;user.id&#125;</span>&gt;</span>&#123;user.name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">       )) : null&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> UserList;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>当组件 <code>UserList</code> 初次加载时，调用了一次获取用户数据的接口，该接口的返回值用来渲染页面上的用户列表。<code>useEffect</code> 函数的第二个参数就表示这个 hook 在组件渲染到页面后只会调用一次，可以编写一个自定义 hook 将这种只执行一次的 effect 抽象成自定义 hook。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * use-mount.jsx</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> React, &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useMount = <span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (callback &amp;&amp; <span class="keyword">typeof</span> callback === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      callback();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, []);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useMount;</span><br></pre></td></tr></table></figure>

<p>调用 <code>useMount</code> 自定义 hook 时传入一个函数作为参数，<code>useMount</code> 会去执行这个回调函数，并且只会在组件渲染到页面后只执行一次。使用方法：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * user-list.jsx</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> useMount <span class="keyword">from</span> <span class="string">&#x27;use-mount&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> UserList = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [users, setUsers] = useState([]);</span><br><span class="line">  useMount(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    fetch(<span class="string">&#x27;/users&#x27;</span>).then(<span class="keyword">async</span> response =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (response.ok) &#123;</span><br><span class="line">        setUsers(<span class="keyword">await</span> response.json());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// do something...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;users ? users.map((user) =&gt; (</span></span><br><span class="line"><span class="xml">         <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;user.id&#125;</span>&gt;</span>&#123;user.name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">       )) : null&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> UserList;</span><br></pre></td></tr></table></figure>

<p>可以发现，和直接使用 <code>useEffect</code> 很相似，区别是使用 <code>useMount</code> 自定义 hook 时省略了 <code>useEffect</code> hook 的第二个参数空数组。之后就可以把只在组件加载后执行一次的副作用操作都写在 <code>useMount</code> 自定义 hook 中了。</p>
<div class="post-ggad"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-6487844781006261" data-ad-slot="3432081921"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div>]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React Hooks</tag>
        <tag>React 钩子函数</tag>
        <tag>React 自定义 Hook</tag>
      </tags>
  </entry>
  <entry>
    <title>前端:使用 Mock Service Worker 模拟数据</title>
    <url>/post/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E4%B8%AD%E4%BD%BF%E7%94%A8-Mock-Service-Worker-%E6%A8%A1%E6%8B%9F%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在项目根目录执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install msw --save-dev</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">$ yarn add msw --dev</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="定义-mocks（模拟-REST-API）"><a href="#定义-mocks（模拟-REST-API）" class="headerlink" title="定义 mocks（模拟 REST API）"></a>定义 mocks（模拟 REST API）</h2><p>使用 request handler 来定义要模拟的请求。</p>
<ol>
<li><p>创建 <code>src/mocks</code> 目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mkdir src/mocks</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建 <code>src/mocks/handler.js</code> 文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ touch src/mocks/handlers.js</span><br></pre></td></tr></table></figure>
</li>
<li><p>从 <code>msw</code> 导入 <code>rest</code> :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/mocks/handlers.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; rest &#125; <span class="keyword">from</span> <span class="string">&quot;msw&quot;</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>以下面两个 API 为例：</p>
<ul>
<li><code>POST /login</code>，允许用户登录。</li>
<li><code>GET /user</code>，返回登录用户的信息。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/mocks/handlers.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; rest &#125; <span class="keyword">from</span> <span class="string">&quot;msw&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> handlers = [</span><br><span class="line">  <span class="comment">// Handles a POST /login request</span></span><br><span class="line">  rest.post(<span class="string">&quot;/login&quot;</span>, <span class="literal">null</span>),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Handles a GET /user request</span></span><br><span class="line">  rest.get(<span class="string">&quot;/user&quot;</span>, <span class="literal">null</span>),</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>要模拟返回值，需要在对应的 <code>post</code> 或 <code>get</code> 方法中传入 response resolver。response resolver 函数接受 3 个参数：</p>
<ul>
<li><code>req</code>：匹配的请求信息。</li>
<li><code>res</code>：用于模拟返回值的方法集。</li>
<li><code>ctx</code>：设置 <code>status code</code>、<code>headers</code>、<code>body</code>等。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/mocks/handlers.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; rest &#125; <span class="keyword">from</span> <span class="string">&quot;msw&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> handlers = [</span><br><span class="line">  rest.post(<span class="string">&quot;/login&quot;</span>, <span class="function">(<span class="params">req, res, ctx</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Persist user&#x27;s authentication in the session</span></span><br><span class="line">    sessionStorage.setItem(<span class="string">&quot;is-authenticated&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res(</span><br><span class="line">      <span class="comment">// Respond with a 200 status code</span></span><br><span class="line">      ctx.status(<span class="number">200</span>)</span><br><span class="line">    );</span><br><span class="line">  &#125;),</span><br><span class="line"></span><br><span class="line">  rest.get(<span class="string">&quot;/user&quot;</span>, <span class="function">(<span class="params">req, res, ctx</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Check if the user is authenticated in this session</span></span><br><span class="line">    <span class="keyword">const</span> isAuthenticated = sessionStorage.getItem(<span class="string">&quot;is-authenticated&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isAuthenticated) &#123;</span><br><span class="line">      <span class="comment">// If not authenticated, respond with a 403 error</span></span><br><span class="line">      <span class="keyword">return</span> res(</span><br><span class="line">        ctx.status(<span class="number">403</span>),</span><br><span class="line">        ctx.json(&#123;</span><br><span class="line">          <span class="attr">errorMessage</span>: <span class="string">&quot;Not authorized&quot;</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If authenticated, return a mocked user details</span></span><br><span class="line">    <span class="keyword">return</span> res(</span><br><span class="line">      ctx.status(<span class="number">200</span>),</span><br><span class="line">      ctx.json(&#123;</span><br><span class="line">        <span class="attr">username</span>: <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">  &#125;),</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<h2 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h2><p>上面的 <code>src/mocks/handlers.js</code> 文件在 Browser 和 Node 环境是通用的。因为 Service Worder 不支持在 Node 中运行，所以集成过程因环境而异。</p>
<h3 id="集成到-Browser-环境"><a href="#集成到-Browser-环境" class="headerlink" title="集成到 Browser 环境"></a>集成到 Browser 环境</h3><p>使用 Mock Service Worker CLI 工具在项目根目录执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npx msw init &lt;PUBLIC_DIR&gt; --save</span><br></pre></td></tr></table></figure>

<p>将 <code>&lt;PUBLIC_DIR&gt;</code> 替换成你项目中的 public 目录。比如，使用的是 Create React App 创建的项目应执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npx msw init public/ --save</span><br></pre></td></tr></table></figure>

<p><a href="https://mswjs.io/docs/getting-started/integrate/browser#where-is-my-public-directory">如何确定 <code>public</code> 目录？</a></p>
<h4 id="配置-worker"><a href="#配置-worker" class="headerlink" title="配置 worker"></a>配置 worker</h4><ul>
<li><p>在 <code>src/mocks</code> 目录下创建 <code>browser.js</code> 文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ touch src/mocks/browser.js</span><br></pre></td></tr></table></figure>
</li>
<li><p>从 <code>msw</code> 导入 <code>setupWorker</code> 方法，把上面创建的 <code>src/mocks/handler.js</code> 文件中的 <code>handler</code> 也一并导入进来：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/mocks/browser.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; setupWorker &#125; <span class="keyword">from</span> <span class="string">&quot;msw&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; handlers &#125; <span class="keyword">from</span> <span class="string">&quot;./handlers&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This configures a Service Worker with the given request handlers.</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> worker = setupWorker(...handlers);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="启动-worker"><a href="#启动-worker" class="headerlink" title="启动 worker"></a>启动 worker</h4><p>Mock Service Worker 不应被用于生产环境，应在测试环境中使用：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/index.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&quot;./App&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">&quot;development&quot;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; worker &#125; = <span class="built_in">require</span>(<span class="string">&quot;./mocks/browser&quot;</span>);</span><br><span class="line">  worker.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>));</span><br></pre></td></tr></table></figure>

<h4 id="验证和检查"><a href="#验证和检查" class="headerlink" title="验证和检查"></a>验证和检查</h4><p>在浏览器控制台中应能看到打印出的成功的消息：</p>
<p><img src="/images/2021/02/XGFC5j.png" alt="验证和检查 msw"></p>
<h3 id="集成到-Node-环境"><a href="#集成到-Node-环境" class="headerlink" title="集成到 Node 环境"></a>集成到 Node 环境</h3><p>参阅 <a href="https://mswjs.io/docs/getting-started/integrate/node">这里</a> 的文档说明，按照步骤可将 msw 集成到 Node 环境。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Mock Service Worker 是一个非常强大的 mock server 库，可查看 <a href="https://mswjs.io/">官网</a> 查看详细信息。</p>
<div class="post-ggad"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-6487844781006261" data-ad-slot="3432081921"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div>]]></content>
      <categories>
        <category>前端</category>
        <category>Mock Server</category>
      </categories>
      <tags>
        <tag>server</tag>
        <tag>Mock Service Worker</tag>
        <tag>msw</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 之 Array 中的迭代器方法</title>
    <url>/post/JavaScript-%E4%B9%8B-Array-%E4%B8%AD%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p><code>Array</code> 的原型上暴露了 3 个用于检索数组内容的迭代器方法：<code>keys()</code>、<code>values()</code> 和 <code>entries()</code>。</p>
<ul>
<li><code>keys()</code>：返回数组索引的迭代器。</li>
<li><code>values()</code>：返回数组元素的迭代器。</li>
<li><code>entries()</code>：返回索引&#x2F;值对的迭代器。</li>
</ul>
<span id="more"></span>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> strings = [<span class="string">&quot;hi-ruofei.com&quot;</span>, <span class="string">&quot;https://hi-ruofei.com&quot;</span>, <span class="string">&quot;Hello world&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为这些方法返回的都是迭代器，所以可以将他们的内容</span></span><br><span class="line"><span class="comment">// 通过 Array.from() 直接转换为数组实例</span></span><br><span class="line"><span class="keyword">const</span> keys = <span class="built_in">Array</span>.from(strings.keys());</span><br><span class="line"><span class="keyword">const</span> values = <span class="built_in">Array</span>.from(strings.values());</span><br><span class="line"><span class="keyword">const</span> entries = <span class="built_in">Array</span>.from(strings.entries());</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(keys); <span class="comment">// [0, 1, 2]</span></span><br><span class="line"><span class="built_in">console</span>.log(values); <span class="comment">// [&#x27;hi-ruofei.com&#x27;, &#x27;https://hi-ruofei.com&#x27;, &#x27;Hello world.&#x27;];</span></span><br><span class="line"><span class="built_in">console</span>.log(entries); <span class="comment">// [[0, &#x27;hi-ruofei.com&#x27;], [1, &#x27;https://hi-ruofei.com&#x27;], [2, &#x27;Hello world&#x27;]]</span></span><br></pre></td></tr></table></figure>

<p>使用 ES6 的解构可以非常容易地在循环中拆分键&#x2F;值对：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> strings = [<span class="string">&quot;hi-ruofei.com&quot;</span>, <span class="string">&quot;https://hi-ruofei.com&quot;</span>, <span class="string">&quot;Hello world&quot;</span>];</span><br><span class="line"><span class="keyword">const</span> entries = <span class="built_in">Array</span>.from(strings.entries());</span><br><span class="line"><span class="keyword">const</span> result = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [idx, element] <span class="keyword">of</span> entries) &#123;</span><br><span class="line">  result[element] = &#123; idx &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * result:</span></span><br><span class="line"><span class="comment"> * &#123;</span></span><br><span class="line"><span class="comment"> *   &#x27;hi-ruofei.com&#x27;: &#123; idx: 0 &#125;,</span></span><br><span class="line"><span class="comment"> *   &#x27;https://hi-ruofei.com&#x27;: &#123; idx: 0 &#125;,</span></span><br><span class="line"><span class="comment"> *   &#x27;Hello world&#x27;: &#123; idx: 0 &#125;,</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure>

<div class="post-ggad"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-6487844781006261" data-ad-slot="3432081921"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript 语法</tag>
        <tag>JavaScript 集合引用类型</tag>
        <tag>JavaScript Array</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 之检测数组</title>
    <url>/post/JavaScript-%E4%B9%8B%E6%A3%80%E6%B5%8B%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>要判断一个对象是不是数组，ECMAScript 提供了 2 种检测方式，他们分别是：</p>
<ul>
<li><code>instanceof</code> 操作符</li>
<li><code>Array.isArray()</code> 方法</li>
</ul>
<span id="more"></span>

<p>在只有一个全局作用域的情况下，使用 <code>instanceof</code> 操作符即可：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">  <span class="comment">// 操作数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>instanceof</code> 的问题是假设只有一个全局上下文。如果网页中有多个框架，则可能存在两个以上全局执行上下文，因此可能会有多个不同的 <code>Array</code> 构造函数。当从一个框架中将数组传递给另外一个框架时，则这个数组的构造函数将有别于第二个框架中的数组。</p>
<p>为了解决这个问题，ECMAScript 提供了 <code>Array.isArray()</code> 方法。这个方法的作用就是确定一个值是否为数组，而不用管它是在哪个全局上下文中创建的。下面是一个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">  <span class="comment">// 操作数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="post-ggad"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-6487844781006261" data-ad-slot="3432081921"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript 语法</tag>
        <tag>JavaScript 集合引用类型</tag>
        <tag>JavaScript Array</tag>
      </tags>
  </entry>
  <entry>
    <title>在 Mac 上使用 gitolite 搭建 Git 服务器</title>
    <url>/post/%E5%9C%A8-Mac-%E4%B8%8A%E4%BD%BF%E7%94%A8-gitolite-%E6%90%AD%E5%BB%BA-Git-%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul>
<li>使用 gitolite 搭建本地 git 服务</li>
<li>通过 iCloud 同步仓库</li>
</ul>
<h2 id="准备-ssh-key"><a href="#准备-ssh-key" class="headerlink" title="准备 ssh key"></a>准备 ssh key</h2><p>使用 <code>ssh-keygen</code> 命令生成 ssh key：</p>
<span id="more"></span>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -b 4096</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/Users/&lt;username&gt;/.ssh/id_rsa):</span><br><span class="line">Created directory <span class="string">&#x27;/Users/ruofei/.ssh&#x27;</span>.</span><br><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved <span class="keyword">in</span> /Users/&lt;username&gt;/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved <span class="keyword">in</span> /Users/&lt;username&gt;/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:Q80nJRy3c+QEW8Sr1...j63sm3mXw &lt;username&gt;@mbp.local</span><br><span class="line">The key<span class="string">&#x27;s randomart image is:</span></span><br><span class="line"><span class="string">+---[RSA 4096]----+</span></span><br><span class="line"><span class="string">|     ..o .o.+=B+.|</span></span><br><span class="line"><span class="string">|     .. oo.+ B+ o|</span></span><br><span class="line"><span class="string">|.    ..  ..      |</span></span><br><span class="line"><span class="string">+----[SHA256]-----+</span></span><br></pre></td></tr></table></figure>

<p>默认会在 <code>/Users/&lt;username&gt;/.ssh/</code> 目录下随机生成 ssh key，建议输入一个密码。</p>
<h2 id="允许远程登录-MacBook"><a href="#允许远程登录-MacBook" class="headerlink" title="允许远程登录 MacBook"></a>允许远程登录 MacBook</h2><p>打开 <code>系统偏好设置</code> -&gt; <code>共享</code>，勾选 <code>远程登录</code>：</p>
<p><img src="/images/2021/03/knM4zu.png" alt="远程登录"></p>
<h2 id="使用-iCloud-同步裸仓库"><a href="#使用-iCloud-同步裸仓库" class="headerlink" title="使用 iCloud 同步裸仓库"></a>使用 iCloud 同步裸仓库</h2><p>因 gitolite 服务器部署在本地，所以当我们重装系统时，一般会将 gitolite 服务的裸仓库都做一次备份。方便起见，这里使用 iCloud 同步我们的裸仓库。</p>
<p>在 iCloud 中创建一个名为 <code>repositories</code> 的文件夹，打开终端，cd 到 iCloud 根目录下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ /Users/&lt;username&gt;/Library/Mobile\ Documents/com~apple~CloudDocs/</span><br></pre></td></tr></table></figure>

<p>创建 <code>repositories</code> 目录的软连接到当前登录用户的家目录下的 <code>repositories</code> 目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo ln -s /Users/&lt;username&gt;/Library/Mobile\ Documents/com\~apple\~CloudDocs/repositories/ /Users/git/repositories</span><br></pre></td></tr></table></figure>

<p>下面测试一下 iCloud 的同步功能是否正常。cd 到 <code>/Users/git/repositories</code> 目录下，创建一个名为 <code>test</code> 的测试文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /Users/&lt;username&gt;/repositories &amp;&amp; touch <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>接下来，打开 iCloud 中的 <code>repositories</code> 文件夹，如果能看到我们刚才创建的这个 <code>test</code> 文件，就说明 iCloud 的同步功能是正常的。</p>
<div class="tabs" id="测试-icloud-同步功能是否正常"><ul class="nav-tabs"><li class="tab active"><a href="#测试-icloud-同步功能是否正常-1">/Users/git/repositories/ 目录下的内容</a></li><li class="tab"><a href="#测试-icloud-同步功能是否正常-2">iCloud 中 repositories 目录下的内容</a></li></ul><div class="tab-content"><div class="tab-pane active" id="测试-icloud-同步功能是否正常-1"><p><img src="/images/2021/03/fozuqm.png"></p></div><div class="tab-pane" id="测试-icloud-同步功能是否正常-2"><p><img src="/images/2021/03/8gIbvw.jpg"></p></div></div></div>

<h2 id="安装、配置-gitolite"><a href="#安装、配置-gitolite" class="headerlink" title="安装、配置 gitolite"></a>安装、配置 gitolite</h2><p>首先，克隆 gitolite 的源码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/sitaramc/gitolite</span><br><span class="line"><span class="comment"># 如果克隆 github 上的仓库失败，可以通过国内镜像仓库克隆，速度快很多</span></span><br><span class="line"><span class="comment"># git clone https://gitee.com/mirrors/gitolite.git</span></span><br></pre></td></tr></table></figure>

<p>克隆源码后建立 gitolite 软连接：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mkdir -p ~/bin</span><br><span class="line">$ gitolite/install -ln /Users/&lt;username&gt;/bin <span class="comment"># 需使用绝对路径</span></span><br></pre></td></tr></table></figure>

<p>再将 <code>gitolite</code> 追加到 <code>.bash_profile</code> 中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=/Users/&lt;username&gt;/bin:<span class="variable">$PATH</span> <span class="comment"># 如果用 zsh 那就将这句话添加到 .bashrc 文件，注意将 &lt;username&gt; 替换成你的用户名</span></span><br></pre></td></tr></table></figure>

<p>最后设置管理员用户共钥：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gitolite setup -pk YourName.pub <span class="comment"># 这里的 YourName.pub 就是之前生成的共钥（ssh key），通常叫做 id_rsa.pub</span></span><br></pre></td></tr></table></figure>

<p>上面的命令执行成功之后，会在 iCloud 的 <code>repositories</code> 目录下创建两个仓库：</p>
<ul>
<li><code>gitolite-admin.git</code>：这是管理员仓库，添加人员、权限等操作需要将这个仓库克隆下来在其冲的 config 中配置。</li>
<li><code>testing.git</code>：这个是一个测试仓库。</li>
</ul>
<p><img src="/images/2021/03/2xkXB3.png" alt="初始化的两个仓库"></p>
<p>之后我们提交的代码都会同步到 iCloud。</p>
<p>因为我们是在本地搭建的 gitolite，所以还要在当前管理员用户的 <code>.ssh</code> 目录下创建一个配置文件 config：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vim ~/.ssh/config</span><br></pre></td></tr></table></figure>

<p>config 文件中填写：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Host <span class="built_in">local</span> <span class="comment"># local 就表示本机（127.0.0.1）</span></span><br><span class="line">    HostName 127.0.0.1</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>将 <code>gitolite-admin.git</code> 仓库克隆下来：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &lt;username&gt;@<span class="built_in">local</span>:gitolite-admin.git <span class="comment"># &lt;username&gt; 是你的用户名</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/2021/03/fHnR56.png" alt="克隆 gitolite-adming.git 仓库"></p>
<p>用编辑器打开 <code>gitolite-admin</code> 仓库，修改其中的 <code>gitolite.conf</code> 文件：</p>
<p><img src="/images/2021/03/ZEeaGy.png" alt="修改 gitolite.conf 文件"></p>
<p>图中新加的名为 <code>hi-ruofei.com</code> 仓库名就是本站的源码仓库。</p>
<p>修改之后，提交到 gitolite，gitolite 会自动帮我们创建一个名为 <code>hi-ruofei.com</code> 的裸仓库，该仓库会同步到 iCloud 上。</p>
<p><img src="/images/2021/03/x51QfE.png" alt="自动创建 hi-ruofei.com 裸仓库"></p>
<p><img src="/images/2021/03/vY8mFa.png" alt="保存在 iCloud 上的裸仓库"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://gitolite.com/">Gitolite</a></li>
<li><a href="https://blog.csdn.net/a464057216/article/details/52644021">45.在 Mac 上使用 gitolite 搭建 Git 服务器</a><div class="post-ggad"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-6487844781006261" data-ad-slot="3432081921"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></li>
</ul>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>gitolite</tag>
      </tags>
  </entry>
  <entry>
    <title>Cloudflare 转发 GitHub Gist</title>
    <url>/post/Cloudflare-%E8%BD%AC%E5%8F%91-GitHub-Gist/</url>
    <content><![CDATA[<p>本文记录了如何在 MediaWiki 中插入 GitHub Gist 代码片段。</p>
<span id="more"></span>

<h2 id="编写-MediaWiki-扩展-gists-php"><a href="#编写-MediaWiki-扩展-gists-php" class="headerlink" title="编写 MediaWiki 扩展 gists.php"></a>编写 MediaWiki 扩展 gists.php</h2><p>首先编写一个 MediaWiki 扩展，文件命名为 <code>gists.php</code>：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Extension for MediaWiki to include GitHub Gists in pages.</span></span><br><span class="line"><span class="comment"> * Copyright (C) 2021 若非 &lt;rf.wangchn<span class="doctag">@foxmail</span>.com&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@file</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ingroup</span> Extensions</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 若非 &lt;rf.wangchn<span class="doctag">@foxmail</span>.com&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$wgExtensionCredits</span>[<span class="string">&#x27;gists&#x27;</span>][] = <span class="keyword">array</span>(</span><br><span class="line">  <span class="string">&#x27;path&#x27;</span> =&gt; <span class="keyword">__FILE__</span>,</span><br><span class="line">  <span class="string">&#x27;name&#x27;</span> =&gt; <span class="string">&#x27;Gists&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;author&#x27;</span> =&gt; <span class="string">&#x27;若非&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;url&#x27;</span> =&gt; <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;description&#x27;</span> =&gt; <span class="string">&#x27;在你的 MediaWiki 中插入 GitHub Gist 代码片段。&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;version&#x27;</span> =&gt; <span class="number">1.0</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="variable">$wgHooks</span>[<span class="string">&#x27;ParserFirstCallInit&#x27;</span>][] = <span class="string">&#x27;mvGists&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add the &lt;gist&gt; tag to the parser.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> Parser $parser Parser object</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> bool true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mvGists</span>(<span class="params"> Parser <span class="variable">$parser</span> </span>) </span>&#123;</span><br><span class="line">  <span class="variable">$parser</span>-&gt;setHook( <span class="string">&#x27;gist&#x27;</span>, <span class="string">&#x27;mvGistRender&#x27;</span> );</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Parses $input (gist number) and embeds gist code.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $input Contents of tag</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array $args Attributes to the tag</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> Parser $parser Parser object</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> PPFrame $frame Current parser grame</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mvGistRender</span>(<span class="params"> <span class="variable">$input</span>, <span class="keyword">array</span> <span class="variable">$args</span>, Parser <span class="variable">$parser</span>, PPFrame <span class="variable">$frame</span> </span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>( !<span class="keyword">empty</span>( <span class="variable">$args</span>[<span class="string">&#x27;files&#x27;</span>] ) ) &#123;</span><br><span class="line">    <span class="variable">$files</span> = explode( <span class="string">&#x27; &#x27;</span>, <span class="variable">$args</span>[<span class="string">&#x27;files&#x27;</span>] );</span><br><span class="line">  &#125; <span class="keyword">elseif</span>( !<span class="keyword">empty</span>( <span class="variable">$args</span>[<span class="string">&#x27;file&#x27;</span>] ) ) &#123;</span><br><span class="line">    <span class="variable">$files</span> = <span class="keyword">array</span>( <span class="variable">$args</span>[<span class="string">&#x27;file&#x27;</span>] );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable">$files</span> = <span class="keyword">array</span>( <span class="string">&#x27;&#x27;</span> );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>( !ctype_xdigit( <span class="variable">$input</span> ) ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;!!! Invalid gist number&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable">$gistId</span> = trim( <span class="variable">$input</span> );</span><br><span class="line">    <span class="variable">$output</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">foreach</span>( <span class="variable">$files</span> <span class="keyword">as</span> <span class="variable">$file</span> ) &#123;</span><br><span class="line">      <span class="comment">// 代理了 GitHub Gist</span></span><br><span class="line">      <span class="comment">// see: https://dash.cloudflare.com/a85714920ae16e02e952fe71641d9a70/workers/view/gist</span></span><br><span class="line">      <span class="variable">$output</span> .= Html::linkedScript( <span class="string">&quot;https://gist.icoder.workers.dev/<span class="subst">&#123;$input&#125;</span>.js?file=<span class="subst">&#123;$file&#125;</span>&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$output</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建完成后，将该扩展文件放到 MediaWiki 站点根目录的 <code>extensions/gists/</code> 目录下。</p>
<p>在中国大陆无法访问 <a href="https://gist.github.com/">https://gist.github.com/（点我试一下你能访问吗？）</a>，借助 <a href="https://dash.cloudflare.com/">Cloudflare</a> 可以将其转发到其他域名下，这样就可以访问 <a href="https://gist.github.com/">https://gist.github.com/</a> 了。</p>
<h2 id="创建-Worker"><a href="#创建-Worker" class="headerlink" title="创建 Worker"></a>创建 Worker</h2><p>在 Cloudflare 中创建一个 worker，内容如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">addEventListener(<span class="string">&quot;fetch&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> url = event.request.url.split(<span class="string">&quot;https://gist.icoder.workers.dev/&quot;</span>)[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">return</span> event.respondWith(fetch(<span class="string">`https://gist.github.com/<span class="subst">$&#123;url&#125;</span>`</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>代码中第 2 行是 Cloudflare 提供的 worker.dev 路由，部署后通过该地址即可访问 Github Gist 中的代码片段。不要开启你本地的 vpn，访问一下这个地址试一下：<a href="https://gist.icoder.workers.dev/smpower/4814c681a44629f43b2f8455c436f669">https://gist.icoder.workers.dev/smpower/4814c681a44629f43b2f8455c436f669</a>。通过这个地址打开的页面就包含了上面的两个代码片段。</p>
<h2 id="启用-gists-扩展"><a href="#启用-gists-扩展" class="headerlink" title="启用 gists 扩展"></a>启用 gists 扩展</h2><p>在 MediaWiki 的配置文件 <code>LocalSettings.php</code> 中启用该扩展：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 省略了其他配置项...</span></span><br><span class="line"><span class="keyword">require_once</span> <span class="string">&quot;<span class="subst">$IP</span>/extensions/gists/gists.php&quot;</span>;</span><br></pre></td></tr></table></figure>

<div class="post-ggad"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-6487844781006261" data-ad-slot="3432081921"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div>]]></content>
      <categories>
        <category>MediaWiki</category>
      </categories>
      <tags>
        <tag>Extensions</tag>
        <tag>扩展</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次博客优化</title>
    <url>/post/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>之前，使用 Netlify 做全球加速，以提高访问速度。后来效果不是很明显，切换到了 Vercel，加速效果很好，结果前几天网站突然就不能在国内访问了～排查了一下发现需要科学上网才能正常访问，抽时间又把网站托管到 GitHub Pages 上了。</p>
<span id="more"></span>

<p>虽然能访问 GitHub Pages 页面，但是在国内访问的速度慢到让你怀疑人生。都已经要狠心买 CDN 了，突然想到了 jsDelivr——这货是为开发者提供的开源免费的 CDN，许多 npm 包都是通过 jsDelivr 来加速的，还有 GitHub 仓库也能加速访问。</p>
<p>用户在访问托管到 GitHub Pages 上的页面时，需要加载许多静态资源，像一些 js、css 和图像都是从 GitHub 仓库中加载的，如果把这部分资源使用 jsDelivr 加速的话，网站的访问速度就快的多了，这样用户只需要从 GitHub Pages 加载 html 文件，其他资源统统走 jsDelivr，就能解决访问慢的问题。</p>
<p>本站使用 Hexo + NexT 主题搭建，要在 NexT 主题下配置 jsDelivr 也非常简单——改一下配置文件就能实现。不过在修改配置文件之前，还是先看看 NexT 是怎么引入静态资源的吧。</p>
<p>打开项目的 <code>node_modules</code> 文件夹，找到 Next 主题 <code>hexo-theme-next</code> 文件夹。这个文件夹就是用到的主题，在主题文件夹下找到 <code>layout</code> -&gt; <code>_partials</code> -&gt; <code>head</code> 文件夹下的 <code>head.njk</code> 文件，打开。</p>
<p>这个文件就是 HTML 文件中的 head 部分，所有的 js 和 css 资源都是在这个文件中引入的。看看其中有没有关于主题的样式，像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;&#123;&#123; url_for(theme.css) &#125;&#125;/main.css&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>很显然，这个 main.css 样式文件的路径是在配置文件中配置的，找一下配置文件中的 css 属性，你会看到这样一段代码（通常在配置文件的最后位置）：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Assets</span></span><br><span class="line"><span class="comment"># Accelerate delivery of static files using a CDN</span></span><br><span class="line"><span class="attr">css:</span> <span class="string">css</span></span><br><span class="line"><span class="attr">js:</span> <span class="string">js</span></span><br><span class="line"><span class="attr">images:</span> <span class="string">images</span></span><br></pre></td></tr></table></figure>

<p>结合上面引入 css 的路径，就明白了：main.css 文件是在根目录下的 css 文件夹下引入的。所以，我们只需要把配置文件中的 css、js 和 images 属性值设置为 jsDelivr 提供的地址就可以了。</p>
<p>以下面我的配置为例：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Assets</span></span><br><span class="line"><span class="comment"># Accelerate delivery of static files using a CDN</span></span><br><span class="line"><span class="attr">css:</span> <span class="string">https://cdn.jsdelivr.net/gh/smpower/smpower.github.io/css</span> <span class="comment"># css</span></span><br><span class="line"><span class="attr">js:</span> <span class="string">https://cdn.jsdelivr.net/gh/smpower/smpower.github.io/js</span> <span class="comment"># js</span></span><br><span class="line"><span class="attr">images:</span> <span class="string">https://cdn.jsdelivr.net/gh/smpower/smpower.github.io/images</span> <span class="comment"># images</span></span><br></pre></td></tr></table></figure>

<p>打开本站的控制台，刷新一下页面你会发现所有的静态资源都是从上面的 cdn 中加载的，并且访问速度相当给力，整个页面的加载用时在 3s 以内，这速度简直完爆 GitHub Pages。</p>
<p>还在等什么，在你的网站上也搞一哈吧！Happy Coding！</p>
<div class="post-ggad"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-6487844781006261" data-ad-slot="3432081921"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div>]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>（JS）Chrome 下载 PDF 文件：（JS）解决 Chrome 浏览器下载 PDF 而不是预览 PDF</title>
    <url>/post/Chrome-%E4%B8%8B%E8%BD%BD-PDF-%E6%96%87%E4%BB%B6%EF%BC%9A%E8%A7%A3%E5%86%B3-Chrome-%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8B%E8%BD%BD-PDF-%E8%80%8C%E4%B8%8D%E6%98%AF%E9%A2%84%E8%A7%88-PDF/</url>
    <content><![CDATA[<p>在前端开发中遇到这样一个问题：在 Chrome 中通过一个链接下载 PDF 文件时却被 Chrome 浏览器打开预览了，这不是我想要的效果，点击 PDF 链接的时候我希望下载这个文件而不是去预览。这里提供一个解决方案，将 PDF 文件通过 <code>XMLHttpRequest</code> 请求的方式，将文件转换为文件流，然后实现下载 PDF 的功能。</p>
<span id="more"></span>

<p>具体 JS 代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>文件链接转文件流下载（主要针对 pdf - 解决谷歌浏览器 a 标签下直接打开 pdf 的问题）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>url 文件链接</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>fileName 文件名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>type 文件类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> fileLink2StreamDownload = <span class="function">(<span class="params">&#123; url, fileName, type &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> reg =</span><br><span class="line">    <span class="regexp">/^([hH][tT]&#123;2&#125;[pP]:\/\/|[hH][tT]&#123;2&#125;[pP][sS]:\/\/)(([A-Za-z0-9-~]+).)+([A-Za-z0-9-~\/])+$/</span>;</span><br><span class="line">  <span class="keyword">if</span> (!reg.test(url))</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;传入参数不合法，`url` 不是标准的文件链接&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  <span class="comment">// 规定请求的类型、URL 以及是否异步处理请求。</span></span><br><span class="line">  <span class="comment">//   三个参数分别是</span></span><br><span class="line">  <span class="comment">//     - method：请求的类型（GET 或 POST ）</span></span><br><span class="line">  <span class="comment">//     - url：文件在服务器上的位置</span></span><br><span class="line">  <span class="comment">//     - async：true（异步）或 false（同步）</span></span><br><span class="line">  xhr.open(<span class="string">&quot;get&quot;</span>, url, <span class="literal">true</span>);</span><br><span class="line">  xhr.setRequestHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">`application/<span class="subst">$&#123;type&#125;</span>`</span>);</span><br><span class="line">  xhr.responseType = <span class="string">&quot;blob&quot;</span>;</span><br><span class="line">  xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> blob = <span class="keyword">new</span> Blob([<span class="built_in">this</span>.response], &#123; <span class="attr">type</span>: <span class="string">`application/<span class="subst">$&#123;type&#125;</span>`</span> &#125;);</span><br><span class="line">      <span class="keyword">const</span> objectUrl = URL.createObjectURL(blob);</span><br><span class="line">      <span class="keyword">const</span> ele = <span class="built_in">document</span>.createElement(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">      ele.href = objectUrl;</span><br><span class="line">      ele.download = fileName;</span><br><span class="line">      ele.click();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  xhr.send();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>fileLink2StreamDownload</code> 方法内部通过 <code>XMLHttpRequest</code> 发起一个 GET 请求，设置请求的响应类型为 <code>blob</code>，然后在页面上创建一个隐藏的 <code>a</code> 标签，然后点击一下这个 <code>a</code> 标签，实现 PDF 的下载功能。这里的关键是将文件链接转换为 <code>blob</code> 文件流来实现下载 PDF。如果 PDF 的链接有权限验证的话，可以用你项目中封装好的 <code>request</code> 方法代替上面的 <code>XMLHttpRequest</code> 方法。</p>
<p>上面的方法是经过项目验证过的，你可以放心大胆的 copy 过去，根据你的项目略作修改就能用了！甚至都不用改就可以。</p>
<div class="post-ggad"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-6487844781006261" data-ad-slot="3432081921"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div>]]></content>
      <categories>
        <category>前端</category>
        <category>QA</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Chrome</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 入门之安装教程</title>
    <url>/post/Docker-%E5%85%A5%E9%97%A8%E4%B9%8B%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>本篇介绍了在 Mac OS, Windows, Linux 下的 Docker 安装方法。开始之前我们先看一下官方对 Docker 的介绍：</p>
<blockquote>
<p>Docker Engine is available for Linux (<a href="https://store.docker.com/editions/community/docker-ce-server-centos">CentOS</a>, <a href="https://store.docker.com/editions/community/docker-ce-server-debian">Debian</a>, <a href="https://store.docker.com/editions/community/docker-ce-server-fedora">Fedora</a>, <a href="https://store.docker.com/editions/enterprise/docker-ee-server-oraclelinux">Oracle Linux</a>, <a href="https://store.docker.com/editions/enterprise/docker-ee-server-rhel">RHEL</a>, <a href="https://store.docker.com/editions/enterprise/docker-ee-server-sles">SUSE</a>, and <a href="https://store.docker.com/editions/community/docker-ce-server-ubuntu">Ubuntu</a>) or <a href="https://store.docker.com/editions/enterprise/docker-ee-server-windows">Windows Server</a> operating systems and is based on containerd - the open source container runtime project that Docker donated to the Cloud Native Computing Foundation (CNCF) in 2017. It is available as both a free community-supported engine and as a commercially-supported enterprise engine (Docker Engine-Enterprise) that also forms the foundation for an enterprise container platform.</p>
</blockquote>
<p>通过官方的介绍我们不难发现，Docker 已经基本上覆盖了全平台，对于英文好的朋友，直接去官网按照指南一步一步安装即可。</p>
<p>英文一般的朋友，继续往下看吧那就～</p>
<span id="more"></span>

<h2 id="Mac-OS-上的-Docker-安装方法"><a href="#Mac-OS-上的-Docker-安装方法" class="headerlink" title="Mac OS 上的 Docker 安装方法"></a>Mac OS 上的 Docker 安装方法</h2><p>第一种方法是下载官方的 <code>dmg</code> 安装包：</p>
<p><a href="https://hub.docker.com/editions/community/docker-ce-desktop-mac">Docker Descktop for Mac</a></p>
<p>安装该软件包对系统的要求：</p>
<blockquote>
<p>Requires Apple Mac OS Sierra 10.12 or above. Download <a href="https://docs.docker.com/toolbox/overview/">Docker Toolbox</a> for previous OS versions.</p>
</blockquote>
<p>只要系统是 Mac OS Sierra 10.12 以上即可。</p>
<p>下载完 <code>Docker.dmg</code> 安装包之后，双击即可以安装，可能需要系统管理员权限，输入密码即可。</p>
<p>安装成功后，在系统菜单栏上会有 Docker 的小图标：</p>
<p><img src="/images/2021/06/Xt0mTI.png" alt="Docker 小图标"></p>
<p>安装完之后，在终端工具中，使用 <code>docker version</code> 来查看 Docker 版本。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ docker version</span><br><span class="line">Client:</span><br><span class="line"> Cloud integration: 1.0.14</span><br><span class="line"> Version:           20.10.6</span><br><span class="line"> API version:       1.41</span><br><span class="line"> Go version:        go1.16.3</span><br><span class="line"> Git commit:        370c289</span><br><span class="line"> Built:             Fri Apr  9 22:46:57 2021</span><br><span class="line"> OS/Arch:           darwin/amd64</span><br><span class="line"> Context:           default</span><br><span class="line"> Experimental:      <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">Server: Docker Engine - Community</span><br><span class="line"> Engine:</span><br><span class="line">  Version:          20.10.6</span><br><span class="line">  API version:      1.41 (minimum version 1.12)</span><br><span class="line">  Go version:       go1.13.15</span><br><span class="line">  Git commit:       8728dd2</span><br><span class="line">  Built:            Fri Apr  9 22:44:56 2021</span><br><span class="line">  OS/Arch:          linux/amd64</span><br><span class="line">  Experimental:     <span class="literal">false</span></span><br><span class="line"> containerd:</span><br><span class="line">  Version:          1.4.4</span><br><span class="line">  GitCommit:        05f951a3781f4f2c1911b05e61c160e9c30eaa8e</span><br><span class="line"> runc:</span><br><span class="line">  Version:          1.0.0-rc93</span><br><span class="line">  GitCommit:        12644e614e25b05da6fd08a38ffa0cfe1903fdec</span><br><span class="line"> docker-init:</span><br><span class="line">  Version:          0.19.0</span><br><span class="line">  GitCommit:        de40ad0</span><br></pre></td></tr></table></figure>

<p>设置中国区加速地址：</p>
<p><img src="/images/2021/06/xaybI4.png" alt="设置 Docker 中国区加速地址"></p>
<p>上面打码的地址是阿里云提供的 Docker 镜像加速地址，每个人都可以去申请一个个人镜像地使用。</p>
<blockquote>
<p>阿里云 Docker 镜像加速：<a href="https://yq.aliyun.com/articles/29941">Docker 镜像加速器</a></p>
</blockquote>
<p>第二种方法是通过 <code>brew cask</code> 安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ brew update</span><br><span class="line">➜  ~ brew cask install docker</span><br><span class="line">➜  ~ brew cask uninstall docker <span class="comment"># 删除的方法, 还需要手动删除Docker.app</span></span><br></pre></td></tr></table></figure>

<p>上面的命令将会把 Docker 安装在 <code>Applications</code> 目录下。</p>
<h2 id="Windows-上-Docker-安装"><a href="#Windows-上-Docker-安装" class="headerlink" title="Windows 上 Docker 安装"></a>Windows 上 Docker 安装</h2><p>官方下载地址：<a href="https://hub.docker.com/editions/community/docker-ce-desktop-windows">Docker Desktop for Windows</a></p>
<p>对系统的要求：</p>
<blockquote>
<p>Requires Microsoft Windows 10 Professional or Enterprise 64-bit. For previous versions get <a href="https://docs.docker.com/toolbox/overview/">Docker Toolbox</a>.</p>
</blockquote>
<p>需要 Windows 10 专业版及企业的 64 位版本，在 Windows server 2016 以上亲测是可用的。Windows 8&#x2F;7&#x2F;Vista&#x2F;Xp 之类的，就别想了，老实去装 Windows 10 或者虚拟机中去使用。</p>
<h2 id="Linux-上-Docker-安装"><a href="#Linux-上-Docker-安装" class="headerlink" title="Linux 上 Docker 安装"></a>Linux 上 Docker 安装</h2><p>下面介绍最常见的 Linux 系统下安装 Docker 的方法。</p>
<h3 id="Centos-中-Docker-安装方法"><a href="#Centos-中-Docker-安装方法" class="headerlink" title="Centos 中 Docker 安装方法"></a>Centos 中 Docker 安装方法</h3><ol>
<li><p>先删除旧的版本（如果没有可以跳过）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum remove docker docker-client docker-client-latest docker-common docker-latest docker-latest-logrotate docker-logrotate docker-engine</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装必须的依赖：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure>

<p>添加 <code>stable</code> 的 Docker-ce 的源：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装 <code>docker-ce</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>
</li>
<li><p>选择指定的安装版本（可选）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum list docker-ce --showduplicates | sort -r</span><br><span class="line">docker-ce.x86_64  3:18.09.1-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64  3:18.09.0-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64  18.06.1.ce-3.el7                    docker-ce-stable</span><br><span class="line">docker-ce.x86_64  18.06.0.ce-3.el7                    docker-ce-stable</span><br></pre></td></tr></table></figure>

<p>我们来举个例子，比如我们要安装 <code>3:18.09.1-3.el7</code> 这个版本，使用如下命令结构：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ sudo yum install docker-ce- docker-ce-cli- containerd.io</span><br></pre></td></tr></table></figure>

<p>第一部分是 <code>docker-ce</code>，第二部分是版本号 <code>18.09.1</code>，看明白了吗？就是这样子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum install -y docker-ce-18.09.1 docker-ce-cli-18.09.1</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动服务并测试一下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl start docker <span class="comment"># 启动服务</span></span><br><span class="line">$ sudo docker run hello-world <span class="comment"># 来一个 Hello World 吧</span></span><br><span class="line">Unable to find image <span class="string">&#x27;hello-world:latest&#x27;</span> locally</span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">1b930d010525: Pull complete</span><br><span class="line">Digest: sha256:2557e3c07ed1e38f26e389462d03ed943586f744621577a99efb77324b0fe535</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> hello-world:latest</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line">1. The Docker client contacted the Docker daemon.</span><br><span class="line">2. The Docker daemon pulled the <span class="string">&quot;hello-world&quot;</span> image from the Docker Hub.</span><br><span class="line">(amd64)</span><br><span class="line">3. The Docker daemon created a new container from that image <span class="built_in">which</span> runs the</span><br><span class="line">executable that produces the output you are currently reading.</span><br><span class="line">4. The Docker daemon streamed that output to the Docker client, <span class="built_in">which</span> sent it</span><br><span class="line">to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line">$ docker run -it ubuntu bash</span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line">https://hub.docker.com/</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line">https://docs.docker.com/get-started/</span><br></pre></td></tr></table></figure>

<p>如果看到上面的提示，说明 Docker 已经成功安装并运行了。</p>
</li>
<li><p>关于升级&amp;删除：</p>
<p>升级：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum -y update <span class="comment"># 更新所有</span></span><br><span class="line">$ yum -y update docker-ce docker-ce-cli containerd.io <span class="comment"># 更新指定</span></span><br></pre></td></tr></table></figure>

<p>删除：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum remove docker-ce</span><br><span class="line">$ sudo rm -rf /var/lib/docker <span class="comment"># 删除文件系统</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Debian-中-Docker-的安装方法"><a href="#Debian-中-Docker-的安装方法" class="headerlink" title="Debian 中 Docker 的安装方法"></a>Debian 中 Docker 的安装方法</h3><ol>
<li><p>删除旧的版本(可跳过)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get remove docker docker-engine docker.io containerd runc</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装依赖：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install \</span><br><span class="line">apt-transport-https \</span><br><span class="line">ca-certificates \</span><br><span class="line">curl \</span><br><span class="line">gnupg \</span><br><span class="line">lsb-release</span><br><span class="line">$ curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>stable</code> 安装源：</p>
<ul>
<li>x86_64 &#x2F; amd64</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo add-apt-repository <span class="string">&quot;deb [arch=amd64] https://download.docker.com/linux/debian <span class="subst">$(lsb_release -cs)</span> stable&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>armhf</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo add-apt-repository <span class="string">&quot;deb [arch=armhf] https://download.docker.com/linux/debian <span class="subst">$(lsb_release -cs)</span> stable&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>arm64</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo add-apt-repository <span class="string">&quot;deb [arch=amd64] https://download.docker.com/linux/debian <span class="subst">$(lsb_release -cs)</span> stable&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>安装 <code>docker-ce</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装指定的版本（可选）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ apt-cache madison docker-ce</span><br><span class="line">docker-ce | 5:18.09.1~3-0~debian-stretch | https://download.docker.com/linux/debian stretch/stable amd64 Packages</span><br><span class="line">docker-ce | 5:18.09.0~3-0~debian-stretch | https://download.docker.com/linux/debian stretch/stable amd64 Packages</span><br><span class="line">docker-ce | 18.06.1~ce~3-0~debian        | https://download.docker.com/linux/debian stretch/stable amd64 Packages</span><br><span class="line">docker-ce | 18.06.0~ce~3-0~debian        | https://download.docker.com/linux/debian stretch/stable amd64 Packages</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>安装格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install docker-ce= docker-ce-cli= containerd.io</span><br></pre></td></tr></table></figure>

<p>举例说明：比如要安装 <code>5:18.09.1~3-0~debian-stretch</code> 版本的 docker 的话：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install docker-ce=18.09.1 docker-ce-cli=18.09.1 containerd.io</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动服务并测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo service docker start</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看Docker运行状态</span></span><br><span class="line">$ sudo service docker status</span><br><span class="line">$ sudo docker run hello-world</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Ubuntu-中-Docker-安装方法"><a href="#Ubuntu-中-Docker-安装方法" class="headerlink" title="Ubuntu 中 Docker 安装方法"></a>Ubuntu 中 Docker 安装方法</h3><ol>
<li><p>删除旧的版本(可跳过)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get remove docker docker-engine docker.io containerd runc</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装依赖：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install</span><br><span class="line">apt-transport-https</span><br><span class="line">ca-certificates</span><br><span class="line">curl</span><br><span class="line">gnupg-agent</span><br><span class="line">software-properties-common</span><br><span class="line">$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - <span class="comment"># 添加GPG key</span></span><br><span class="line">$ sudo apt-key fingerprint 0EBFCD88</span><br><span class="line">pub   rsa4096 2017-02-22 [SCEA]</span><br><span class="line">9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88</span><br><span class="line">uid           [ unknown] Docker Release (CE deb)</span><br><span class="line">sub   rsa4096 2017-02-22 [S]</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>stable</code> 安装源：</p>
<ul>
<li><p>x86_64&#x2F;amd64</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo add-apt-repository <span class="string">&quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu <span class="subst">$(lsb_release -cs)</span> stable&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>[armhf]</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo add-apt-repository <span class="string">&quot;deb [arch=armhf] https://download.docker.com/linux/ubuntu <span class="subst">$(lsb_release -cs)</span> stable&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>[arm64]</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo add-apt-repository <span class="string">&quot;deb [arch=arm64] https://download.docker.com/linux/ubuntu <span class="subst">$(lsb_release -cs)</span> stable&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>[ppc64le (IBM Power)]</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo add-apt-repository <span class="string">&quot;deb [arch=ppc64el] https://download.docker.com/linux/ubuntu <span class="subst">$(lsb_release -cs)</span> stable&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>s390x (IBM Z)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo add-apt-repository <span class="string">&quot;deb [arch=s390x] https://download.docker.com/linux/ubuntu <span class="subst">$(lsb_release -cs)</span> stable&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>安装 <code>docker-ce</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装指定的版本（可选）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ apt-cache madison docker-ce  docker-ce | 5:18.09.1~3-0~ubuntu-xenial | https://download.docker.com/linux/ubuntu  xenial/stable amd64 Packages  docker-ce | 5:18.09.0~3-0~ubuntu-xenial | https://download.docker.com/linux/ubuntu  xenial/stable amd64 Packages  docker-ce | 18.06.1~ce~3-0~ubuntu       | https://download.docker.com/linux/ubuntu  xenial/stable amd64 Packages  docker-ce | 18.06.0~ce~3-0~ubuntu       | https://download.docker.com/linux/ubuntu  xenial/stable amd64 Packages  ...</span><br></pre></td></tr></table></figure>

<p>安装格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install docker-ce= docker-ce-cli= containerd.io</span><br></pre></td></tr></table></figure>

<p>举例说明：比如要安装 <code>5:18.09.1~3-0~ubuntu-xenial</code> 版本的 docker 的话：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install docker-ce=18.09.1 docker-ce-cli=18.09.1 containerd.io</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动服务并测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo service docker start</span><br><span class="line">$ sudo service docker status <span class="comment"># 查看 Docker 运行状态</span></span><br><span class="line">$ sudo docker run hello-world</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Docker-compose-集合命令"><a href="#Docker-compose-集合命令" class="headerlink" title="Docker-compose 集合命令"></a>Docker-compose 集合命令</h2><p>Compose 工具是一个 <code>批量</code> 工具，用于运行与管理多个 <code>docker</code> 容器。</p>
<p>官方文档：<a href="https://docs.docker.com/compose/install/">Install Docker Compose</a></p>
<ol>
<li><p>在 Mac&#x2F;Windows 中，已经集成了 docker-compose 命令</p>
</li>
<li><p>在 WindowsServer 中 先启动 PowerShell</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12</span><br></pre></td></tr></table></figure>

<p>然后运行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Invoke-WebRequest <span class="string">&quot;https://github.com/docker/compose/releases/download/1.23.2/docker-compose-Windows-x86_64.exe&quot;</span> -UseBasicParsing -OutFile <span class="variable">$Env</span>:ProgramFilesDockerdocker-compose.exe</span><br></pre></td></tr></table></figure>

<p>然后测试一下：<code>docker-compose --version</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载docker-compose</span></span><br><span class="line">sudo curl -L <span class="string">&quot;https://github.com/docker/compose/releases/download/1.23.2/docker-compose-<span class="subst">$(uname -s)</span>-<span class="subst">$(uname -m)</span>&quot;</span> -o /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line"><span class="comment"># 给予执行权限</span></span><br><span class="line">sudo chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line"><span class="comment"># 测试命令</span></span><br><span class="line">$ docker-compose --version</span><br><span class="line">docker-compose version 1.23.2, build 1110ad01</span><br></pre></td></tr></table></figure></li>
</ol>
<p>以上就是在各个平台安装 Docker 的步骤，欢迎在下方留言交流。</p>
<div class="post-ggad"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-6487844781006261" data-ad-slot="3432081921"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div>]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript Utility Types - Exclude: TypeScript 实用类型 - Exclude</title>
    <url>/post/TypeScript-Utility-Types-Exclude-TypeScript-%E5%AE%9E%E7%94%A8%E7%B1%BB%E5%9E%8B-Exclude/</url>
    <content><![CDATA[<p><code>Exclude&lt;Type, ExcludeUnion&gt;</code> 通过排除联合类型中的指定成员来构造新类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Letter = <span class="string">&#x27;a&#x27;</span> | <span class="string">&#x27;b&#x27;</span> | <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"><span class="keyword">type</span> T0 = Exclude&lt;Letter, <span class="string">&#x27;a&#x27;</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>上例代码中的类型 <code>T0</code> 等价于下面的写法：</p>
<span id="more"></span>

<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> T0 = <span class="string">&#x27;b&#x27;</span> | <span class="string">&#x27;c&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>Exclude</code> 将联合类型 <code>Letter</code> 中的成员 <code>a</code> 排除掉，得到了一个叫 <code>T0</code> 的联合类型。最终在联合类型 <code>T0</code> 中，只有成员 <code>b</code> 和 成员 <code>c</code>。</p>
<p>那么，<code>Exclude&lt;Type, ExcludeUnion&gt;</code> 是如何排除类型成员的呢？下面我们通过它的类型定义文件分析一下：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Exclude from T those types that are assignable to U</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Exclude&lt;T, U&gt; = T <span class="keyword">extends</span> U ? <span class="built_in">never</span> : T;</span><br></pre></td></tr></table></figure>

<p><code>T extends U ? nver : T</code> 类似于 JavaScript 中的三目运算符，这是 TypeScript 2.8 中引入的<strong>条件类型</strong><sup id="fnref:1"><a href="#fn:1" rel="footnote">[1]</a></sup>，意思是：如果 <code>T</code> 类型是 <code>U</code> 类型的子类型的话，返回 <code>never</code><sup id="fnref:2"><a href="#fn:2" rel="footnote">[2]</a></sup>，否则返回 <code>T</code> 类型。通过刚才的例子我们不难发现，<code>Exclude</code> 就是将前面的类型与后面的类型对比，过滤出前面联合类型中独有的成员。</p>
<p><code>Exclude</code> 除了可以排除联合类型中的字符串成员，还可以过滤函数成员：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyUnion = <span class="string">&#x27;a&#x27;</span> | <span class="string">&#x27;b&#x27;</span> | (<span class="function">() =&gt;</span> <span class="built_in">void</span>);</span><br><span class="line"><span class="keyword">type</span> T2 = Exclude&lt;MyUnion, <span class="built_in">Function</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `T2` 类型等价于下面的 `T3` 类型</span></span><br><span class="line"><span class="keyword">type</span> T3 = <span class="string">&#x27;a&#x27;</span> | <span class="string">&#x27;b&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>如果是两个联合类型呢？</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> U1 = <span class="string">&#x27;a&#x27;</span> | <span class="string">&#x27;b&#x27;</span> | <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"><span class="keyword">type</span> U2 = <span class="string">&#x27;b&#x27;</span> | <span class="string">&#x27;5&#x27;</span> | <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"><span class="keyword">type</span> U3 = Exclude&lt;U1, U2&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `U3` 类型等价于下面的 `U4` 类型</span></span><br><span class="line"><span class="keyword">type</span> U4 = <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><code>U3</code> 类型的结果可能让人疑惑，看上去 <code>U1</code> 类型并不是继承自 <code>U2</code> 类型，最后为什么将类型 <code>U1</code> 中的成员 <code>b</code> 和成员 <code>c</code> 过滤掉了呢？首先我们注意到 <code>U1</code> 和 <code>U2</code> 类型都是联合类型，换句话说 <code>U1</code> 类型有可能是 <code>&#39;a&#39;</code>，有可能是 <code>&#39;b&#39;</code>，也有可能是 <code>&#39;c&#39;</code>。显然成员 <code>&#39;a&#39;</code> 没有继承自 <code>U2</code> 类型，而成员 <code>&#39;b&#39;</code> 和成员 <code>&#39;c&#39;</code> 分别继承自类型 <code>U2</code>，所以，最终 <code>Exclude</code> 将 <code>U1</code> 类型中的成员 <code>&#39;b&#39;</code> 和成员 <code>&#39;c&#39;</code> 排除掉，只留下了成员 <code>&#39;a&#39;</code>。</p>
<div id="footnotes"><div id="footnotelist"><div style="border-bottom: 1px solid #eee; font-size: 1.125em; margin-bottom: 10px; margin-top: 60px;">参考</div><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><a href="https://www.typescriptlang.org/docs/handbook/2/conditional-types.html">TypeScript 条件类型</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;"><a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html#the-never-type">TypeScript <code>never</code> 类型</a>
<div class="post-ggad"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-6487844781006261" data-ad-slot="3432081921"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></span><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
        <tag>TypeScript:Utility Types</tag>
        <tag>TypeScript:实用类型</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript Utility Types - Omit: TypeScript 实用类型 - Omit</title>
    <url>/post/TypeScript-Utility-Types-Omit-TypeScript-%E5%AE%9E%E7%94%A8%E7%B1%BB%E5%9E%8B-Omit/</url>
    <content><![CDATA[<p>本篇介绍 TypeScript 实用类型中的 <code>Omit</code> 类型。<code>Omit&lt;Type, Keys&gt;</code> 从类型中选取所有属性，然后通过删除指定键来构造类型。以下面的 <code>User</code> 类型为例：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  gender: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>经 <code>Omit</code> 类型转换后得到：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  gender: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除 `User` 类型中的 `age` 和 `gender` 属性</span></span><br><span class="line"><span class="comment">// 只剩下了 `name` 属性</span></span><br><span class="line"><span class="keyword">type</span> OmitUser = Omit&lt;User, <span class="string">&#x27;age&#x27;</span> | <span class="string">&#x27;gender&#x27;</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> omitUser: OmitUser = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Olive&#x27;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>转换后的 <code>OmitUser</code> 类型与下面的类型是等价的：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> OmitUser = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>那么，<code>Omit</code> 是如何转换类型的呢？我们通过它的类型定义来分析一下：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Construct a type with the properties of T except for those in type K.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Omit&lt;T, K <span class="keyword">extends</span> keyof <span class="built_in">any</span>&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;;</span><br></pre></td></tr></table></figure>

<p><code>Omit</code> 源码的类型定义中有几点需要注意：</p>
<ul>
<li><code>K extends keyof any</code>：这段代码表示泛型 <code>K</code> 继承自联合类型 <code>keyof any</code>；</li>
<li><code>Pick</code> 是 TypeScript 中作用于全局的实用类型，用于从类型中选取一组属性键来构造类型<sup id="fnref:1"><a href="#fn:1" rel="footnote">[1]</a></sup>;</li>
<li><code>Exclude</code> 是 TypeScript 中另一个作用于全局的实用类型，通过排除联合类型中的指定成员来构造新类型<sup id="fnref:2"><a href="#fn:2" rel="footnote">[2]</a></sup>；</li>
<li>通过 <code>Exclude</code> 转换后的类型结果就是要挑选出来的成员，再经过 <code>Pick</code> 将他们从类型 <code>T</code> 中选取出来。</li>
</ul>
<p>在不了解 <code>Pick</code> 和 <code>Exclude</code> 类型作用的情况下，一般难以看懂 <code>Omit</code> 类型的源码。下面参考部分有相关的传送门，当你理解了 <code>Pick</code> 和 <code>Exclude</code> 后回头再看 <code>Omit</code> 就能理解了。</p>
<p><a href="https://www.typescriptlang.org/zh/play#code/C4TwDgpgBAqgzhATlAvFA3gKClAdgQwFsIAuKOYRAS1wHMBubKfW0vAV0ICMlGdXcAEyRkK1OowC+jTKEhQA8oSrB4SVIuXAAPGsQAaKAHIWEI1AA+xgcMRGAfDIDGAe1wUoLrXrJKVejSwcAmIyIwUAGyoANzN9TGkgA">Playground Link</a></p>
<div class="post-ggad"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-6487844781006261" data-ad-slot="3432081921"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div><div id="footnotes"><div id="footnotelist"><div style="border-bottom: 1px solid #eee; font-size: 1.125em; margin-bottom: 10px; margin-top: 60px;">参考</div><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><a href="/post/bdb49a56/">TypeScript 实用类型：<code>Pick</code></a></span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;"><a href="/post/fca5d737/">TypeScript 实用类型：<code>Exclude</code></a></span><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
        <tag>TypeScript:Utility Types</tag>
        <tag>TypeScript:实用类型</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript Utility Types - Partial: TypeScript 实用类型 - Partial</title>
    <url>/post/TypeScript-Utility-Types-Partial-TypeScript-%E5%AE%9E%E7%94%A8%E7%B1%BB%E5%9E%8B-Partial/</url>
    <content><![CDATA[<p><code>Partial&lt;Type&gt;</code> 可将一个类型中所有属性转换为可选属性。假设我们有一个 <code>user</code> 的类型，如下：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  gender: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>经 <code>Partial&lt;Type&gt;</code> 转换后得到：</p>
<span id="more"></span>

<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> PartialUser = Partial&lt;User&gt;;</span><br><span class="line"><span class="keyword">const</span> partialUser: PartialUser = &#123;</span><br><span class="line">  <span class="comment">/** `name` 属性是可选的 */</span></span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Olive&quot;</span>,</span><br><span class="line">  <span class="comment">/** `age` 属性是可选的 */</span></span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="comment">/** `gender` 属性是可选的 */</span></span><br><span class="line">  <span class="attr">gender</span>: <span class="string">&quot;female&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>转换后的 <code>PartialUser</code> 类型与下面的类型是等价的：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> PartialUser = &#123;</span><br><span class="line">  name?: <span class="built_in">string</span> | <span class="literal">undefined</span>;</span><br><span class="line">  age?: <span class="built_in">number</span> | <span class="literal">undefined</span>;</span><br><span class="line">  gender?: <span class="built_in">string</span> | <span class="literal">undefined</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>那么 <code>Partial&lt;Type&gt;</code> 是如何转换类型的呢？下面是它的源码：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Make all properties in T optional</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Partial&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]?: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>遍历类型 <code>T</code>，将类型 <code>T</code> 中的属性作为 key；</li>
<li>在属性后面加 <code>?</code> 使其变为可选的属性；</li>
<li>可选属性的值为 <code>T</code> 类型中对应属性的值，即 <code>T[P]</code>。</li>
</ul>
<p><a href="https://www.typescriptlang.org/zh/play#code/C4TwDgpgBAqgzhATlAvFA3gKCjqA7AQwFsIAuKOYRASzwHMBubXAus-AVyICMkncobPABMk5SjXpMAvpkyhIUAAoFEwagQA28JKmWr1WgDw7EAPiaYAxgHs8lKGAMbtCRORVqXpvVgEB6ACpAqAADQhJQqEA9HUByA0B6M0B75UBIBMAQtyhA-2YcCPYAcgB5TWoANwg8gBpsqCCQ0NYIKLiktIysgQbyAEYADiqA4LChUUQmhJT0zOrhsSg8gDMIIi1yqukgA">Playground Link</a></p>
<div class="post-ggad"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-6487844781006261" data-ad-slot="3432081921"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
        <tag>TypeScript:Utility Types</tag>
        <tag>TypeScript:实用类型</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript Utility Types - Pick: TypeScript 实用类型 - Pick</title>
    <url>/post/TypeScript-Utility-Types-Pick-TypeScript-%E5%AE%9E%E7%94%A8%E7%B1%BB%E5%9E%8B-Pick/</url>
    <content><![CDATA[<p><code>Pick&lt;Type, Keys&gt;</code> 可从类型中选取一组属性键来构造类型。以下面的 <code>User</code> 类型为例：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  gender: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>经 <code>Pick&lt;Type, Keys&gt;</code> 转换后得到：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  gender: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PickUser = Pick&lt;User, <span class="string">&#x27;name&#x27;</span> | <span class="string">&#x27;age&#x27;</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `PickUser` 类型相对于 `User` 类型少了 `gender` 属性</span></span><br><span class="line"><span class="keyword">const</span> pickUser: PickUser = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Olive&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>转换后的 <code>PickUser</code> 类型与下面的类型是等价的：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> PickUser = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>那么，<code>Pick&lt;Type, Keys&gt;</code> 是如何转换类型的呢？我们通过它的类型定义来分析一下：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * From T, pick a set of properties whose keys are in the union K</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Pick&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123;</span><br><span class="line">    [P <span class="keyword">in</span> K]: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结合上面的示例，<code>Pick</code> 类型定义中的泛型 <code>T</code> 就是我们刚才定义的类型 <code>User</code>，后面的 <code>K extends keyof T</code> 则表示泛型 <code>K</code> 继承自联合类型 <code>keyof T</code>，由此可以得出泛型 <code>K</code> 是一个联合类型。</p>
<p>通过关键字 <code>in</code> 来遍历联合类型 <code>K</code>，将联合类型中的每个成员作为 key，通过方括号语法访问类型 <code>T</code> 中该成员对应的值，即 <code>T[P]</code>。</p>
<p>以上就是 <code>Pick&lt;Type, Keys&gt;</code> 的用法和类型定义的解析，欢迎在下方留言交流。</p>
<p><a href="https://www.typescriptlang.org/zh/play#code/C4TwDgpgBAqgzhATlAvFA3gKClAdgQwFsIAuKOYRAS1wHMBubKfW0vAV0ICMlGdXcAEyRkK1OowC+jTKEhQAClQDGAa3hJUilaoA8GxABooAcgLETUAD6mWEEwD4ZAemdQABkrUH3UQN4+gNHqgB9ugJ-agHFyHj7+AYCIOoBhch4Cwoi+gHo6gOQGmMoA9rgUUGA6BmRe6gjIaFg45mwmAPIANlQAbvaGTHZkAIwAHO3SmEA">Playground Link</a></p>
<div class="post-ggad"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-6487844781006261" data-ad-slot="3432081921"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
        <tag>TypeScript:Utility Types</tag>
        <tag>TypeScript:实用类型</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript Utility Types - Readonly: TypeScript 实用类型 - Readonly</title>
    <url>/post/TypeScript-Utility-Types-Readonly-TypeScript-%E5%AE%9E%E7%94%A8%E7%B1%BB%E5%9E%8B-Readonly/</url>
    <content><![CDATA[<p><code>Readonly&lt;Type&gt;</code> 可将一个类型中所有属性转换为<strong>只读</strong>属性。以 <code>User</code> 类型为例：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  gender: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>经 <code>Readonly&lt;Type&gt;</code> 转换后得到：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadonlyUser = Readonly&lt;User&gt;;</span><br><span class="line"><span class="keyword">const</span> readonlyUser: ReadonlyUser = &#123;</span><br><span class="line">  <span class="comment">/** `name` 属性是只读的 */</span></span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Olive&#x27;</span>,</span><br><span class="line">  <span class="comment">/** `age` 属性是只读的 */</span></span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="comment">/** `gender` 属性是只读的 */</span></span><br><span class="line">  <span class="attr">gender</span>: <span class="string">&#x27;female&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转换后的 <code>ReadonlyUser</code> 类型与下面的类型是等价的：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadonlyUser = &#123;</span><br><span class="line">  <span class="keyword">readonly</span> name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">readonly</span> age: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">readonly</span> gender: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>Readonly&lt;Type&gt;</code> 是如何转换类型的呢？</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** * Make all properties in T readonly */</span></span><br><span class="line"><span class="keyword">type</span> Readonly&lt;T&gt; = &#123;</span><br><span class="line">  <span class="keyword">readonly</span> [P <span class="keyword">in</span> keyof T]: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>遍历类型 <code>T</code>，将类型 <code>T</code> 中的属性作为 key；</li>
<li>在属性 key 前面加 <code>readonly</code> 修饰符，使其转换为只读属性；</li>
<li>只读属性的值为 <code>T</code> 类型中对应属性的值，即 <code>T[P]</code>。</li>
</ul>
<p><a href="https://www.typescriptlang.org/zh/play#code/C4TwDgpgBAqgzhATlAvFA3gKCjqA7AQwFsIAuKOYRASzwHMBubXAus-AVyICMkncobPABMk5SjXpMAvpkyhIUAEoQCwgPZ4ANiHhJUy1Ru0gAPHsQA+JpgDGmylERHNOi+RVrXuhMjRYBAHoAKmCoAANCEnCoQD0dQHIDQHozQCvlQG-owBC3KGDA5hwo9gByAHktagA3CAKAGlyoELDw1ggYhJSMrJyBJvIARgAOGqDQiKFRRBaktMzs2tGxKAKAMwgiAi1KmtlMQMCoQFPowFmTQB15QFg5QGqIwEFFQA7owBh-wAO1QC45COcvEwsYwFo5bd3MyOJmuLxQBPumdADbxgCNjB6hNKhBKAIAZvs8XG9fJ90oABI0AkOYJQC-CW10giXsY3L4AHT5AwFABSBFsAGsCgwgA">Playground Link</a></p>
<div class="post-ggad"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-6487844781006261" data-ad-slot="3432081921"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
        <tag>TypeScript:Utility Types</tag>
        <tag>TypeScript:实用类型</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript Utility Types - Record: TypeScript 实用类型 - Record</title>
    <url>/post/TypeScript-Utility-Types-Record-TypeScript-%E5%AE%9E%E7%94%A8%E7%B1%BB%E5%9E%8B-Record/</url>
    <content><![CDATA[<p><code>Record&lt;Keys, Type&gt;</code> 可构造一个对象类型，其属性 key 是 key，属性值是类型。该类型可用于将一个类型的属性映射到另一个类型。</p>
<p>假设我们有一个 <code>User</code> 类型，如下：</p>
<span id="more"></span>

<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  gender: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经 <code>Record&lt;Keys, Type&gt;</code> 转换后得到：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> NewUser = Record&lt;<span class="string">&quot;name&quot;</span> | <span class="string">&quot;age&quot;</span> | <span class="string">&quot;gender&quot;</span>, <span class="built_in">string</span>&gt;;</span><br><span class="line"><span class="keyword">const</span> newUser: NewUser = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Olive&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="string">&quot;18&quot;</span>, <span class="comment">// 注意这里</span></span><br><span class="line">  <span class="attr">gender</span>: <span class="string">&quot;female&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>转换后的 <code>NewUser</code> 类型与下面的类型是等价的：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">string</span>;</span><br><span class="line">  gender: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最开始定义的 <code>User</code> 类型中 <code>age</code> 属性为 <code>number</code> 类型，为什么经过 <code>Record&lt;Keys, Type&gt;</code> 转换后 <code>age</code> 属性变为 <code>string</code> 类型了呢？下面根据 <code>Record&lt;Keys, Type&gt;</code> 的类型定义来分析一下：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Construct a type with a set of properties K of type T</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Record&lt;K <span class="keyword">extends</span> keyof <span class="built_in">any</span>, T&gt; = &#123;</span><br><span class="line">    [P <span class="keyword">in</span> K]: T;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>类型定义中有一个操作符 <code>keyof</code> 和一个关键字 <code>in</code>，要理解 <code>Record&lt;Keys, Type&gt;</code> 如何工作，这两个知识点是必须要知道的。</p>
<ul>
<li><p><code>keyof</code> 操作符可以获取一个类型的所有键，返回一个这些键的联合类型：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  gender: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> UserPropType = keyof User;</span><br></pre></td></tr></table></figure>

<p>上面代码中 <code>UserPropType</code> 的类型等价于下面的类型：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> UserPropType = <span class="string">&#x27;name&#x27;</span> | <span class="string">&#x27;age&#x27;</span> | <span class="string">&#x27;gender&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>由上面的示例可知：<code>keyof</code> 操作符获取一个类型中所有 key，并返回这些 key 的联合类型。所以上面 <code>Record</code> 的用法还可以改写成这样：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> NewUser = Record&lt;keyof User, <span class="built_in">string</span>&gt;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>in</code> 是一个 <code>类型关键字</code>，可以对联合类型进行遍历，只可用在 <code>type</code> 关键字下。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  [key <span class="keyword">in</span> <span class="string">&#x27;name&#x27;</span> | <span class="string">&#x27;age&#x27;</span>]: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Person =&gt; &#123; name: number; age: number; &#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>知道了 <code>keyof</code> 操作符和 <code>in</code> 关键字的作用，<code>Record&lt;Keys, Type&gt;</code> 的类型定义也就清楚了：</p>
<ul>
<li>类型 <code>K</code> 继承自联合类型 <code>keyof any</code>；</li>
<li>通过关键字 <code>in</code> 遍历联合类型 <code>K</code>，并将遍历的结果作为 key；</li>
<li>key 的值是类型 <code>T</code>。</li>
</ul>
<p>现在回头看 <code>Record&lt;Keys, Type&gt;</code> 的定义是不是就理解了呢？欢迎在下方留言交流。</p>
<p><a href="https://www.typescriptlang.org/zh/play#code/C4TwDgpgBAqgzhATlAvFA3gKCjqA7AQwFsIAuKOYRASzwHMBubXAus-AVyICMkncobPABMk5SjXpMAvpjmhIUAHIQA7vCSooAJQgBjAPaJhAHgDWEEAYBmsBIgA0FKrToA+JpkN5K+NRsRyFXV7LSwcQhJyACIAeQAbagA3CGiHZlZ2aIBGAA40qAB6QqhAC5tAeENATfjAGcTmIVFAqGjrCCICeNT06QYgA">Playground Link</a></p>
<div class="post-ggad"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-6487844781006261" data-ad-slot="3432081921"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
        <tag>TypeScript:Utility Types</tag>
        <tag>TypeScript:实用类型</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript Utility Types - Required: TypeScript 实用类型 - Required</title>
    <url>/post/TypeScript-Utility-Types-Required-TypeScript-%E5%AE%9E%E7%94%A8%E7%B1%BB%E5%9E%8B-Required/</url>
    <content><![CDATA[<p><code>Required&lt;Type&gt;</code> 类型与 <code>[Partial&lt;Type&gt;](#Partial-lt-Type-gt)</code> 类型的作用相反，<code>Required&lt;Type&gt;</code> 可将一个类型中的可选属性转换为必选属性。以 <code>User</code> 类型为例：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age?: <span class="built_in">number</span>;</span><br><span class="line">  gender: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p><code>User</code> 类型中的 <code>age</code> 属性是可选属性，当经过 <code>Required&lt;Type&gt;</code> 转换后，该属性会被转换成必选属性：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> RequiredUser = Required&lt;User&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> requiredUser: RequiredUser = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Olive&quot;</span>,</span><br><span class="line">  <span class="comment">/** `age` 属性由可选转成了必选 */</span></span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">gender</span>: <span class="string">&quot;female&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下面是 <code>Required&lt;Type&gt;</code> 的源码：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Make all properties in T required</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Required&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]-?: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意到属性后的 <code>-?</code> 了吗？意思是：去除该属性的可选属性，使其转换为必选的属性。</p>
<p><a href="https://www.typescriptlang.org/zh/play?ssl=16&ssc=3&pln=7&pc=1#code/C4TwDgpgBAqgzhATlAvFA3gKCjqA7AQwFsIAuKOYRASzwHMBubXAus-AVyICMkncobPABMk5SjXpMAvpkyhIUAEoQAjh2qIIw+ElTK1GrcIA8uxAD4mmAMYB7PJShb1m7efIrXx8-qwCAegAqIKgAA0ISMKhAPR1AcgNAejNAUf1ASATAELcoIIDmHEj2AHIAeQAbagA3CHyAGhyoYNCw1gho+OT0zOyBJvIARgAOGsCQ8KFRRBbE1Iys2tGxKHyAMwgiAmLKzGkGIA">Playground Link</a></p>
<div class="post-ggad"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-6487844781006261" data-ad-slot="3432081921"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
        <tag>TypeScript:Utility Types</tag>
        <tag>TypeScript:实用类型</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript Utility Types - Extract: TypeScript 实用类型 - Extract</title>
    <url>/post/TypeScript-Utility-Types-Extract-TypeScript-%E5%AE%9E%E7%94%A8%E7%B1%BB%E5%9E%8B-Extract/</url>
    <content><![CDATA[<p>本篇介绍 TypeScript 实用类型中的 <code>Extract</code> 类型。看字面意思，<code>Extract</code> 是指<strong>取出</strong>、<strong>挑出</strong>的意思，<code>Extract</code> 会挑选出传入的两个联合类型中相同的成员，将这些相同的成员构造成一个新类型，构造的新类型有可能是联合类型，也有可能是其他任何类型。</p>
<p>下面是一个简单的例子：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> U1 = <span class="string">&quot;a&quot;</span> | <span class="string">&quot;b&quot;</span> | <span class="string">&quot;c&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> U2 = <span class="string">&quot;a&quot;</span> | <span class="string">&quot;f&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> T0 = Extract&lt;U1, U2&gt;;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>上面代码中定义了两个联合类型 <code>U1</code> 和 <code>U2</code>，这两个联合类型中有一个相同的成员 <code>&quot;a&quot;</code>，<code>Extract</code> 会将该成员 <code>&quot;a&quot;</code> 取出来构造一个新类型。构造的新类型 <code>T0</code> 等价于下面的类型：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 `Extract` 构造了一个新的字符串类型 `NewT0`</span></span><br><span class="line"><span class="keyword">type</span> NewT0 = <span class="string">&quot;a&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>如果在两个联合类型中，存在多个相同的成员（两个及以上）时，<code>Extract</code> 会将这些成员构造成一个新的<strong>联合类型</strong>，下面是另一个例子：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> U3 = <span class="string">&quot;a&quot;</span> | <span class="string">&quot;b&quot;</span> | <span class="string">&quot;c&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> U4 = <span class="string">&quot;a&quot;</span> | <span class="string">&quot;f&quot;</span> | <span class="string">&quot;c&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> T1 = Extract&lt;U3, U4&gt;;</span><br></pre></td></tr></table></figure>

<p>上面两个联合类型 <code>U3</code> 和 <code>U4</code> 中存在多个相同的成员：<code>&quot;a&quot;</code> 和 <code>&quot;c&quot;</code>，<code>Extract</code> 会将他们构造成一个新的联合类型，联合类型 <code>T1</code> 与下面的类型是等价的：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> NewT1 = <span class="string">&quot;a&quot;</span> | <span class="string">&quot;c&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>对初学者来说，还有一种情况容易受到误导，看下面的例子：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> U5 = <span class="built_in">string</span> | <span class="built_in">number</span> | (<span class="function">() =&gt;</span> <span class="built_in">void</span>);</span><br><span class="line"><span class="keyword">type</span> U6 = <span class="built_in">Function</span>;</span><br><span class="line"><span class="keyword">type</span> T2 = Extract&lt;U5, U6&gt;; <span class="comment">// type T2 = () =&gt; void;</span></span><br></pre></td></tr></table></figure>

<p>从字面量的角度来看，<code>U5</code> 和 <code>U6</code> 两个联合类型中并没有相同的成员，但是从类型角度来说 <code>() =&gt; void</code> 表示的是一个函数，它的类型与 <code>Function</code> 是等价的，因此构造出的新类型 <code>T</code> 是一个函数。</p>
<p>了解了 <code>Extract</code> 的用法，下面看一下它的类型定义源码，<code>Extract</code> 在实现上非常简单，源码如下：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Extract from T those types that are assignable to U</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Extract&lt;T, U&gt; = T <span class="keyword">extends</span> U ? T : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure>

<p>通过 <code>Extract</code> 的源码我们不难发现，<code>Extract</code> 从 <code>T</code> 类型中取出 <code>T</code> 和 <code>U</code> 类型中共有的成员来构造一个新类型，如果其中没有共有成员，将返回 <code>never</code> 类型。</p>
<div class="post-ggad"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-6487844781006261" data-ad-slot="3432081921"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
        <tag>TypeScript:Utility Types</tag>
        <tag>TypeScript:实用类型</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript Utility Types - NonNullable: TypeScript 实用类型 - NonNullable</title>
    <url>/post/TypeScript-Utility-Types-NonNullable-TypeScript-%E5%AE%9E%E7%94%A8%E7%B1%BB%E5%9E%8B-NonNullable/</url>
    <content><![CDATA[<p>本篇介绍 TypeScript 实用类型中的 <code>NonNullable&lt;Type&gt;</code> 类型。<code>NonNullable</code> 会从传入的类型中将 <code>null</code> 和 <code>undefined</code> 排除，之后把剩下的成员构造成一个新类型。</p>
<p>下面是一个简单的例子：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> U1 = <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">type</span> T0 = NonNullable&lt;U1&gt;;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>上面的代码中定义了一个名为 <code>U1</code> 的联合类型，<code>NonNullable</code> 会将该类型中的 <code>undefined</code> 排除，再将剩余的成员构造成新的类型 <code>T0</code>，类型 <code>T0</code> 等价于下面的类型：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> NewT0 = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br></pre></td></tr></table></figure>

<p>再看一个包含成员 <code>null</code> 的例子：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> U2 = <span class="built_in">string</span>[] | <span class="literal">null</span> | <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">type</span> T1 = NonNullable&lt;U2&gt;;</span><br></pre></td></tr></table></figure>

<p>上面的类型 <code>U2</code> 中包含成员 <code>null</code>，因此 <code>NonNullable</code> 会把 <code>null</code> 和 <code>undefined</code> 都排除掉，构造的新类型便是 <code>string[]</code>。类型 <code>T1</code> 等价于下面的类型：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> NewT1 = <span class="built_in">string</span>[];</span><br></pre></td></tr></table></figure>

<p><code>NonNullable</code> 的类型定义源码中通过 <code>extends</code> 实现，源码如下：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Exclude null and undefined from T</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> NonNullable&lt;T&gt; = T <span class="keyword">extends</span> <span class="literal">null</span> | <span class="literal">undefined</span> ? <span class="built_in">never</span> : T;</span><br></pre></td></tr></table></figure>

<p><code>never</code> 表示从来不会出现的值的类型，因此联合类型的当成员为 <code>null</code> 或 <code>undefined</code> 时，<code>NonNullable</code> 会将他们排除，只留下联合类型中的其他成员，通过保留下来的成员构造新的类型，也就是源码中的 <code>T</code> 类型。</p>
<div class="post-ggad"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-6487844781006261" data-ad-slot="3432081921"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
        <tag>TypeScript:Utility Types</tag>
        <tag>TypeScript:实用类型</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Docker 搭建 MediaWiki</title>
    <url>/post/%E4%BD%BF%E7%94%A8-Docker-%E6%90%AD%E5%BB%BA-MediaWiki/</url>
    <content><![CDATA[<p>本文介绍了使用 Docker 镜像搭建 MediaWiki 的步骤和方法。借助 Docker 能非常方便的搭建个人维基站点，在数据的备份等维护操作上同样也很便利。使用 Docker 镜像搭建的维基站点，不会在宿主机上安装 LNMP 或 LAMP 环境，能始终保持宿主机的干净清爽。</p>
<span id="more"></span>

<h3 id="准备镜像"><a href="#准备镜像" class="headerlink" title="准备镜像"></a>准备镜像</h3><ol>
<li>mediawiki 镜像：<code>docker pull mediawiki</code>；</li>
<li>mariadb 镜像：<code>docker pull mariadb</code>；</li>
<li>nginx 镜像：<code>docker pull nginx</code>。</li>
</ol>

<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-6487844781006261"
     data-ad-slot="3432081921"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>


<h3 id="启动-mariadb-数据库容器"><a href="#启动-mariadb-数据库容器" class="headerlink" title="启动 mariadb 数据库容器"></a>启动 mariadb 数据库容器</h3><p>终端中执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name mariadb -p 3306:3306 -e MARIADB_ROOT_PASSWORD=my-secret-pw mariadb</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li><code>d</code>：默认不会进入容器。</li>
<li><code>p</code>：将容器内部使用的网络端口 3306 映射到物理机 3306 端口上（注意与参数 <code>P</code> 的区别：将容器内部使用的网络端口随机映射到主机上）。</li>
<li><code>e MARIADB_ROOT_PASSWORD</code>：配置 <code>mariadb</code> 数据库 <code>root</code> 密码。</li>
</ul>
<h3 id="启动-mediawiki-容器"><a href="#启动-mediawiki-容器" class="headerlink" title="启动 mediawiki 容器"></a>启动 mediawiki 容器</h3><p>终端中执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name mediawiki -p 81:80 -p 444:443 --link mariadb:mariadb mediawiki</span><br></pre></td></tr></table></figure>

<p>说明：参数 <code>--link mariadb:mariadb</code> 表示将容器 <code>mariadb</code> 链接到 <code>mediawiki</code> 容器上，冒号（<code>:</code>）前的 <code>mariadb</code> 是上一步运行的 <code>mariadb</code> 容器的名称，冒号后面的 <code>mariadb</code> 是该容器（<code>mediawiki</code> 容器）下的别名。</p>
<h3 id="启动-nginx-容器"><a href="#启动-nginx-容器" class="headerlink" title="启动 nginx 容器"></a>启动 nginx 容器</h3><p>终端中执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name nginx -p 80:80 -p 443:443 nginx</span><br></pre></td></tr></table></figure>


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-6487844781006261"
     data-ad-slot="3432081921"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>


<h3 id="修改-nginx-配置文件"><a href="#修改-nginx-配置文件" class="headerlink" title="修改 nginx 配置文件"></a>修改 nginx 配置文件</h3><p>首先，进入 nginx 容器，cd 到 nginx 的配置目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it nginx bash <span class="comment"># 进入 nginx 容器</span></span><br><span class="line"><span class="built_in">cd</span> /etc/nginx <span class="comment"># cd 到 nginx 的配置目录</span></span><br></pre></td></tr></table></figure>

<p>以下是该目录下的文件和文件夹：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[lighthouse@centos]~% docker exec -it nginx bash</span><br><span class="line">root@df21774abed5:/# cd /etc/nginx</span><br><span class="line">root@df21774abed5:/etc/nginx# ls -al</span><br><span class="line">drwxr-xr-x 1 root root 4096 Oct 16 15:18 .</span><br><span class="line">drwxr-xr-x 1 root root 4096 Oct 16 15:18 ..</span><br><span class="line">drwxr-xr-x 1 root root 4096 Oct 16 15:19 conf.d</span><br><span class="line">-rw-r--r-- 1 root root 1007 Sep  7 15:21 fastcgi_params</span><br><span class="line">-rw-r--r-- 1 root root 5290 Sep  7 15:21 mime.types</span><br><span class="line">lrwxrwxrwx 1 root root   22 Sep  7 15:38 modules -&gt; /usr/lib/nginx/modules</span><br><span class="line">-rw-r--r-- 1 root root  648 Sep  7 15:38 nginx.conf</span><br><span class="line">-rw-r--r-- 1 root root  636 Sep  7 15:21 scgi_params</span><br><span class="line">-rw-r--r-- 1 root root  664 Sep  7 15:21 uwsgi_params</span><br></pre></td></tr></table></figure>

<p>nginx 的默认配置文件是 conf.d 文件夹下的 default.conf 文件，退出容器并将 default.conf 文件从容器中复制到宿主机中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@df21774abed5:/etc/nginx# cp default.conf default.conf.bak # 备份该配置文件</span><br><span class="line">root@df21774abed5:/etc/nginx# exit; # 退出 nginx 容器</span><br><span class="line">exit</span><br><span class="line">[lighthouse@centos]~% docker cp nginx:/etc/nginx/conf.d/default.conf . # 将容器中的 default.conf 文件复制到宿主机</span><br><span class="line">[lighthouse@centos]~% ls -al</span><br><span class="line">drwx------  9 lighthouse lighthouse 4096 Oct 17 00:15 .</span><br><span class="line">drwxr-xr-x. 3 root       root       4096 Nov 23  2020 ..</span><br><span class="line">-rw-r--r--  1 lighthouse lighthouse 1181 Oct 16 23:20 default.conf</span><br></pre></td></tr></table></figure>

<p>修改 <code>default.conf</code> 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    listen  [::]:80;</span><br><span class="line">    server_name  _; # 换成你自己的域名</span><br><span class="line">    # return 301 https://$host$request_uri; # 该行先注释掉，因为还没有证书呢，稍后申请下证书后再取消注释</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_set_header Host $host:$server_port;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_pass &lt;http://172.17.0.1:81/;&gt; # 修改端口号。这个 81 的端口号是上面运行 mediawiki 容器时制定的 81 端口</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen       443 ssl http2;</span><br><span class="line">    listen  [::]:443 ssl http2;</span><br><span class="line">    server_name  _; # 换成你自己的域名</span><br><span class="line"></span><br><span class="line">    # ssl on; #如果强制HTTPs访问，这行要打开</span><br><span class="line">    # ssl_certificate /etc/nginx/certs/ruofei.wiki.crt;</span><br><span class="line">    # ssl_certificate_key /etc/nginx/certs/ruofei.wiki.key;</span><br><span class="line">    ssl_certificate    /www/server/panel/vhost/cert/wiki.hi-ruofei.com/fullchain.pem;</span><br><span class="line">    ssl_certificate_key    /www/server/panel/vhost/cert/wiki.hi-ruofei.com/privkey.pem;</span><br><span class="line">    # ssl_session_timeout 5m;</span><br><span class="line">    # ssl_protocols SSLv2 SSLv3 TLSv1.2; # 指定密码为openssl支持的格式</span><br><span class="line">    # ssl_ciphers HIGH:!aNULL:!MD5; # 密码加密方式</span><br><span class="line">    # ssl_prefer_server_ciphers on; # 依赖SSLv3和TLSv1协议的服务器密码将优先于客户端密码</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_set_header Host $host:$server_port;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_pass &lt;http://172.17.0.1:81/;&gt; # 修改端口号。这个 81 的端口号是上面运行 mediawiki 容器时制定的 81 端口</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改后再将其复制到 <code>nginx</code> 容器中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker cp ./default.conf nginx:/etc/nginx/conf.d</span><br></pre></td></tr></table></figure>

<p>修改 <code>nginx</code> 配置文件，别忘了重启容器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker restart nginx</span><br></pre></td></tr></table></figure>

<p>等待 <code>nginx</code> 容器重启，之后在浏览器中访问 <code>http://your_domain</code> 即可看到 MediaWiki 的安装界面。</p>
<div class="post-ggad"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-6487844781006261" data-ad-slot="3432081921"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div>]]></content>
      <categories>
        <category>MediaWiki</category>
      </categories>
  </entry>
  <entry>
    <title>推荐一款自用的梯子</title>
    <url>/post/%E6%8E%A8%E8%8D%90%E4%B8%80%E6%AC%BE%E8%87%AA%E7%94%A8%E7%9A%84%E6%A2%AF%E5%AD%90/</url>
    <content><![CDATA[<p>有时候我们经常需要使用 Google 搜索资料，毕竟百度的搜索结果中有太多不相关的结果。但是 Google 搜索在大陆地区被墙了，找了好多梯子用都不太理想，最后发现了这个 <a href="https://portal.shadowsocks.nz/aff.php?aff=51884">Shadowsocks</a>，效果很不错，推荐给大家。</p>
<p><img src="/images/2021/11/shadowsocks.png" alt="Shadowsocks"></p>
<p>价格也非常不错，一年才一百来块钱，每个月有 100G 的流量根本用不完，有兴趣的大家自行去看看 -&gt; <a href="https://portal.shadowsocks.nz/aff.php?aff=51884">Shadowsocks</a>。</p>
<span id="more"></span>

<p>这是我半个月的用量，每天都用的情况下：</p>
<p><img src="/images/2021/11/shadowsocks-used.png" alt="Shadowsocks Used"></p>
<p>还有他的产品分类，一个是基础版，还有一个高级版：</p>
<p><img src="/images/2021/11/shadowsocks-cart.png" alt="Shadowsocks Cart"></p>
<p>是不是挺划算的 ;D</p>
<p>官方网站：<a href="https://portal.shadowsocks.nz/aff.php?aff=51884">Shadowsocks</a>。</p>
<div class="post-ggad"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-6487844781006261" data-ad-slot="3432081921"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div>]]></content>
      <categories>
        <category>实用工具</category>
      </categories>
      <tags>
        <tag>shadowsocks</tag>
      </tags>
  </entry>
  <entry>
    <title>MediaWiki 设置短链接（short url）</title>
    <url>/post/MediaWiki-%E8%AE%BE%E7%BD%AE%E7%9F%AD%E9%93%BE%E6%8E%A5%EF%BC%88short-url%EF%BC%89/</url>
    <content><![CDATA[<p>本方法适用于 Apache 服务器。一般情况下，该方法不需要修改 Apache 服务器的配置文件，只需要在 MediaWiki 安装目录下配置 .htaccess 文件即可。</p>
<span id="more"></span>

<h2 id="htaccess-配置文件"><a href="#htaccess-配置文件" class="headerlink" title=".htaccess 配置文件"></a>.htaccess 配置文件</h2><p>在 MediaWiki 根目录下创建 .htaccess 配置文件，并写入一下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Enable the rewrite engine</span><br><span class="line">RewriteEngine On</span><br><span class="line"></span><br><span class="line"># Short URL for wiki pages</span><br><span class="line">RewriteRule ^/?w(/.*)?$ %&#123;DOCUMENT_ROOT&#125;/index.php [L]</span><br><span class="line"></span><br><span class="line"># Redirect / to Main Page</span><br><span class="line">RewriteRule ^/*$ %&#123;DOCUMENT_ROOT&#125;/index.php [L]</span><br></pre></td></tr></table></figure>

<p>第二行代码表示开启 Apache 的重写引擎。</p>
<p>第四行代码中的 <code>%&#123;DOCUMENT_ROOT&#125;/index.php</code> 表示 MediaWiki 根目录下的 index.php 文件，也就是我们访问 MediaWiki 网站时的入口文件，这行代码的意思是当访问 MediaWiki 网站入口时，将其地址重写为 &#x2F;w&#x2F;。比如，当访问这个链接 <a href="https://domain.com/index.php?title=%E9%A6%96%E9%A1%B5">https://domain.com/index.php?title=首页</a> 时，这条规则会将地址重写为 <a href="https://domain.com/%E9%A6%96%E9%A1%B5%E3%80%82%E8%BF%99%E8%A1%8C%E4%BB%A3%E7%A0%81%E6%98%AF%E6%88%91%E4%BB%AC%E5%AE%9E%E7%8E%B0">https://domain.com/首页。这行代码是我们实现</a> MediaWiki 短链接的关键。</p>
<p>最后一行代码，也就是第六行代码表示当访问首页但地址栏没有任何参数时会将页面重定向到 MediaWiki 首页。比如访问 <a href="https://domain.com/">https://domain.com/</a> 时会重定向到 <a href="https://domain.com/index.php%E3%80%82%E8%A2%AB%E9%87%8D%E5%AE%9A%E5%90%91%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%88%E4%BC%9A%E8%A2%AB%E5%BA%94%E7%94%A8%E5%88%B0%E7%AC%AC%E5%9B%9B%E8%A1%8C%E4%BB%A3%E7%A0%81%E7%9A%84%E8%A7%84%E5%88%99%EF%BC%8C%E5%B0%86%E9%95%BF%E9%93%BE%E6%8E%A5%E9%87%8D%E5%86%99%E4%B8%BA%E7%9F%AD%E9%93%BE%E6%8E%A5%EF%BC%8C%E4%B9%9F%E5%B0%B1%E4%BC%9A%E8%A2%AB%E9%87%8D%E5%AE%9A%E5%90%91%E5%88%B0">https://domain.com/index.php。被重定向的地址又会被应用到第四行代码的规则，将长链接重写为短链接，也就会被重定向到</a> <a href="https://domain.com/%E9%A6%96%E9%A1%B5%E3%80%82">https://domain.com/首页。</a></p>
<p>除了修改 .htaccess 配置文件，还需要修改 MediaWIki 的配置文件 LocalSettings.php。</p>
<h2 id="LocalSettings-php-配置文件"><a href="#LocalSettings-php-配置文件" class="headerlink" title="LocalSettings.php 配置文件"></a>LocalSettings.php 配置文件</h2><p>LocalSettings.php 文件位于 MediaWiki 安装目录的根目录下，在该文件最后的位置添加新增以下代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$wgScriptPath</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="variable">$wgArticlePath</span> = <span class="string">&quot;/w/<span class="subst">$1</span>&quot;</span>;</span><br><span class="line"><span class="variable">$wgUsePathInfo</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="variable">$wgScriptExtension</span> = <span class="string">&quot;.php&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>关于这四行代码代表的意思可在 <a href="https://www.mediawiki.org/wiki/Manual:Contents">MediaWiki 网站手册</a>中查看。</p>
<p>至此，即可实现通过短链接访问 MediaWiki。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://wiki.hi-ruofei.com/">若非的维基</a></li>
<li><a href="https://www.mediawiki.org/wiki/Manual:Short_URL/zh">MediaWiki 短链接</a><div class="post-ggad"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-6487844781006261" data-ad-slot="3432081921"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></li>
</ul>
]]></content>
      <categories>
        <category>MediaWiki</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript 根据 url 转换图像（base64）</title>
    <url>/post/JavaScript%20%E6%A0%B9%E6%8D%AE%20url%20%E8%BD%AC%E6%8D%A2%E5%9B%BE%E5%83%8F%EF%BC%88base64%EF%BC%89/</url>
    <content><![CDATA[<p>有时，我们需要根据图片的地址将图片转化为 base64 形式的字符串，然后将转换后的 base64 提交到后台。下面代码演示了如何根据图片的 url 来将其转换成 base64。</p>
<span id="more"></span>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">url2base64</span>(<span class="params">url, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">  img.src = <span class="string">`<span class="subst">$&#123;url&#125;</span>?v=<span class="subst">$&#123;<span class="built_in">Math</span>.random()&#125;</span>`</span>;</span><br><span class="line">  img.setAttribute(<span class="string">&#x27;crossOrigin&#x27;</span>, <span class="string">&#x27;Anonymous&#x27;</span>);</span><br><span class="line">  img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">&#x27;canvas&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> width = img.width;</span><br><span class="line">    <span class="keyword">const</span> height = img.height;</span><br><span class="line">    canvas.width = width;</span><br><span class="line">    canvas.height = height;</span><br><span class="line">    canvas.getContext(<span class="string">&#x27;2d&#x27;</span>).drawImage(img, <span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">    <span class="keyword">const</span> dataURL = canvas.toDataURL(<span class="string">&#x27;image/jpeg&#x27;</span>);</span><br><span class="line">    <span class="keyword">typeof</span> callback === <span class="string">&#x27;function&#x27;</span> &amp;&amp; callback(dataURL);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> url = <span class="string">&#x27;https://www.baidu.com/img/bd_logo1.png&#x27;</span>;</span><br><span class="line">url2base64(url, <span class="function"><span class="params">base64</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(base64);</span><br><span class="line">  <span class="comment">// expected output: 图像的 base64 编码</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<div class="post-ggad"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-6487844781006261" data-ad-slot="3432081921"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript Canvas</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 中的 this</title>
    <url>/post/JavaScript-%E4%B8%AD%E7%9A%84-this/</url>
    <content><![CDATA[<p><code>this</code> 不能在执行期间被赋值，并且在每次函数被调用时 <code>this</code> 的值也有可能不同。在绝大多数情况下，函数的调用方式决定了 <code>this</code> 的值。</p>
<p>在非严格模式下，<code>this</code> 值总是指向一个对象；在严格模式下，<code>this</code> 可以是任意值。</p>
<p>ES5 引入了 bind 方法来设置 <code>this</code> 值，而不用考虑函数是如何被调用的。</p>
<p>ES2015 引入了 箭头函数，而箭头函数则不提供自身的 this 绑定。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Expressions - this</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Randal&#x27;</span>,</span><br><span class="line">  <span class="attr">getName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.getName());</span><br><span class="line"><span class="comment">// expected output: Randal</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="全局上下文中的-this"><a href="#全局上下文中的-this" class="headerlink" title="全局上下文中的 this"></a>全局上下文中的 <code>this</code></h2><p>无论是否在严格模式下，全局环境中的 <code>this</code> 都指向全局对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 浏览器中的 this 值是 window 对象</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span> === <span class="built_in">window</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">name = <span class="string">&#x27;Randal&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name); <span class="comment">// Randal</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.age = <span class="number">18</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.age); <span class="comment">// 18</span></span><br><span class="line"><span class="built_in">console</span>.log(age); <span class="comment">// 18</span></span><br></pre></td></tr></table></figure>

<p>还可以使用 globalThis 获取全局对象。无论我们的代码是否在当前上下文执行，我们都可以用 globalThis 获取全局对象。</p>
<h2 id="函数上下文中的-this"><a href="#函数上下文中的-this" class="headerlink" title="函数上下文中的 this"></a>函数上下文中的 <code>this</code></h2><p>函数内部的 <code>this</code> 值取决于函数被调用的方式。</p>
<h3 id="非严格模式下，函数调用的-this-值"><a href="#非严格模式下，函数调用的-this-值" class="headerlink" title="非严格模式下，函数调用的 this 值"></a>非严格模式下，函数调用的 <code>this</code> 值</h3><p>非严格模式下，若函数调用未设置 <code>this</code> 值，则 <code>this</code> 值默认指向全局对象。浏览器中的全局对象是 window 对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在浏览器中</span></span><br><span class="line">func() === <span class="built_in">window</span>; <span class="comment">// 在浏览器中，全剧对象是 window </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 Node 中</span></span><br><span class="line">func() === globalThis;</span><br></pre></td></tr></table></figure>

<h3 id="严格模式下，函数调用的-this-值"><a href="#严格模式下，函数调用的-this-值" class="headerlink" title="严格模式下，函数调用的 this 值"></a>严格模式下，函数调用的 <code>this</code> 值</h3><p>严格模式下，若进入函数内部的执行环境时没有设置 <code>this</code> 值，则 <code>this</code> 值为 <code>undefined</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func() === <span class="literal">undefined</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>如果要把 <code>this</code> 值从一个环境传到另一个环境，就要用 <a href="app://obsidian.md/JavaScript/标准内置对象/Function/call()">call</a> 或 <a href="app://obsidian.md/apply()">apply</a> 方法。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="string">&#x27;Custom&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个变量，并将该变量作为全局对象的属性</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="string">&#x27;Global&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">whatsThis</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.a; <span class="comment">// this 的值取决于函数被调用的方式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">whtasThis();  <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// expected output: &quot;Global&quot;</span></span><br><span class="line"></span><br><span class="line">whtasThis.call(obj); <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// expected output: &quot;Custom&quot;</span></span><br><span class="line"></span><br><span class="line">whtasThis.apply(obj); <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// expected output: &quot;Custom&quot;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>在非严格模式下，若函数调用未设置 <code>this</code> 值，则 <code>this</code> 值默认指向全局对象。在浏览器中，全局对象为 <code>Window</code>；在 Node 中，全局对象为 <code>globalThis</code>。在 <code>whatsThis</code> 函数体外定义了一个全局变量 <code>a</code>，所以函数 <code>whatsThis</code> 内部 <code>this.a</code> 的值就是全局变量 <code>a</code> 的值。因此，直接调用 <code>whatsThis()</code> 得到的返回值是 <code>Global</code>。</li>
<li>通过调用 <code>whatsThis</code> 函数实例上的 <a href="app://obsidian.md/call()">call()</a> 方法，使 <code>whatsThis</code> 的 <code>this</code> 指向 obj。此时，函数 <code>whatsThis</code> 内部的 <code>this.a</code> 指向的就是对象 <code>obj</code> 的属性 <code>a</code>，因此函数的返回值是 <code>Custom</code>。</li>
<li>调用 <code>whatsThis</code> 函数实例上的 <a href="app://obsidian.md/apply()">apply()</a> 方法，将对象 <code>obj</code> 指定为函数的 <code>this</code> 值。这样，在函数内部访问 <code>this</code> 上的成员 <code>a</code> 时，实际访问的就是对象 <code>obj</code> 中的 <code>a</code> 属性。因此，函数返回值为 <code>Custom</code>。</li>
</ol>
<h2 id="类上下文中的-this"><a href="#类上下文中的-this" class="headerlink" title="类上下文中的 this"></a>类上下文中的 <code>this</code></h2><p><code>this</code> 在[类](app:&#x2F;&#x2F;obsidian.md&#x2F;JavaScript 中的类)中的表现与在函数中类似，因为类的本质也是函数。</p>
<p>在类的构造函数中，<code>this</code> 是一个常规对象。类中所有非静态方法都会被添加到 <code>this</code> 的原型中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> proto = <span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPrototypeNames(proto));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">  <span class="function"><span class="title">getAge</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">getGender</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Person(); <span class="comment">// [&#x27;constructor&#x27;, &#x27;getName&#x27;, &#x27;getAge&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>注意，静态方法不是 <code>this</code> 的属性，它们只是类自身的属性。</p>
<p>派生类的构造函数中没有初始的 <code>this</code> 绑定，可在基类的构造函数中调用 <a href="app://obsidian.md/super">super()</a> 方法生成一个 <code>this</code> 绑定。调用 <a href="app://obsidian.md/super">super()</a> 方法相当于执行以下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span> = <span class="keyword">new</span> Base(); <span class="comment">// Base 为基类</span></span><br></pre></td></tr></table></figure>

<p>注意，在调用 <code>super()</code> 之前引用 <code>this</code> 会抛出错误。</p>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><h3 id="this-和对象转换"><a href="#this-和对象转换" class="headerlink" title="this 和对象转换"></a><code>this</code> 和对象转换</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">c, d</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.a + <span class="built_in">this</span>.b + c +d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add.call(obj, <span class="number">5</span>, <span class="number">7</span>)); <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// expected output: 16</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add.apply(obj, [<span class="number">10</span>, <span class="number">20</span>])); <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// expected output: 34</span></span><br></pre></td></tr></table></figure>

<ol>
<li><code>call()</code> 方法第一个参数用作 <code>this</code> 的对象，表示将函数 <code>add()</code> 方法的 <code>this</code> 绑定到对象 <code>obj</code> 上。这样，当在函数 <code>add()</code> 内部访问 <code>this</code> 时，它会指向到 <code>obj</code> 对象上。其余参数用作函数 <code>add()</code> 的参数。</li>
<li><code>apply()</code> 方法的第一个参数用作 <code>this</code> 的对象，表示将函数 <code>add()</code> 的 <code>this</code> 绑定到对象 <code>obj</code> 上。这样，当在函数 <code>add()</code> 内部访问 <code>this</code> 时，它会指向到 <code>obj</code> 对象上。第二个参数是一个数组，数组中的成员用作 <code>add()</code> 方法的函数参数。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this#%E7%B1%BB%E4%B8%8A%E4%B8%8B%E6%96%87">MDN Web Docs: 类上下文中的 this</a><div class="post-ggad"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-6487844781006261" data-ad-slot="3432081921"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript 表达式和运算符之 this</tag>
      </tags>
  </entry>
  <entry>
    <title>NextJS 入门指南</title>
    <url>/post/NextJS-%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>系统要求：</p>
<ol>
<li>操作系统：MacOS&#x2F;Windows (支持 WSL)&#x2F;Linux</li>
<li>Node.js：&gt;&#x3D; 12.22.0</li>
</ol>
<span id="more"></span>

<h2 id="自动设置"><a href="#自动设置" class="headerlink" title="自动设置"></a>自动设置</h2><p>推荐使用 <code>create-next-app</code> 来自动设置 NextJS 应用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx create-next-app@latest</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">yarn create next-app</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">pnpm create next-app</span><br></pre></td></tr></table></figure>

<p>如果想在创建项目时加入对 TypeScript 的支持，可在命令后面加上 <code>--typescript</code> 参数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx create-next-app@latest --typescript</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">yarn create next-app --typescript</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">pnpm create next-app --typescript</span><br></pre></td></tr></table></figure>

<p>项目创建成功后：</p>
<ol>
<li>运行 <code>npm run dev</code> 或 <code>yarn dev</code> 或 <code>pnpm dev</code> 启动项目；</li>
<li>在浏览器中访问 <a href="http://localhost:3000；">http://localhost:3000；</a></li>
<li>编辑 <code>pages/index.js</code> 文件后，在浏览器中实时查看编译结果（支持热更新）。</li>
</ol>
<h2 id="手动设置"><a href="#手动设置" class="headerlink" title="手动设置"></a>手动设置</h2><p>在项目中安装 <code>next</code>，<code>react</code> 和 <code>react-dom</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install next react react-dom</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">yarn add next react react-dom</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">pnpm add next react react-dom</span><br></pre></td></tr></table></figure>

<p>在的 <code>package.json</code> 文件中加入下面的脚本命令：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;dev&quot;</span>: <span class="string">&quot;next dev&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;next build&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;next start&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;lint&quot;</span>: <span class="string">&quot;next lint&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不同的脚本命令对应不同的开发阶段：</p>
<ul>
<li><code>dev</code> - 开发环境下启动 Next.js</li>
<li><code>build</code> - 生产环境打包 Next.js</li>
<li><code>start</code> - 生产环境下启动 Next.js</li>
<li><code>lint</code> - 设置 Next.js 内置的 ESLint 配置</li>
</ul>
<p>在项目根目录下分别创建两个文件夹 <code>pages</code> 和 <code>public</code>：</p>
<ul>
<li><code>pages</code> - Next.js 会将 <code>pages</code> 文件夹下的每个文件当做一个路由来处理，路由名对应文件名。例如： <code>pages/about.js</code> 将映射为 <code>/about</code></li>
<li><code>public</code> - 存储静态资源，如图像、字体等。<code>public</code> 目录下的文件可以在项目中被引用，引用地址为根路径（&#x2F;）</li>
</ul>
<p>Next.js 中，每个页面（pages 目录下）都是一个 React 组件，文件以 <code>.js</code>、<code>.ts</code>、<code>.jsx</code> 或 <code>.tsx</code> 后缀结尾。通过特定的文件名命名格式，我们甚至可以实现动态路由的功能，比如：<code>[pid].tsx</code>。</p>
<p>以上，就是 Next.js 最基本的入门指南了。</p>
<div class="post-ggad"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-6487844781006261" data-ad-slot="3432081921"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>NextJS 添加 TypeScript</title>
    <url>/post/NextJS-%E6%B7%BB%E5%8A%A0-TypeScript/</url>
    <content><![CDATA[<p>在 NextJS 项目中要添加对 TypeScript 的支持，有两种方式：</p>
<ol>
<li>官方脚手架；</li>
<li>手动安装。</li>
</ol>
<span id="more"></span>

<h2 id="官方脚手架"><a href="#官方脚手架" class="headerlink" title="官方脚手架"></a>官方脚手架</h2><p>在创建新的 NextJS 项目时，可方便的通过官方脚手架来获得对 TypeScript 的支持。只需在脚手架命令后加一个 <code>--ts</code> 或 <code>--typescript</code> 参数即可，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx create-next-app@latest --ts</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">yarn create next-app --typescript</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">pnpm create next-app --ts</span><br></pre></td></tr></table></figure>

<p>在创建新项目时，这种方式是最简单。</p>
<p>若是在现有的 NextJS 项目中添加 TypeScript，就只能手动安装了。</p>
<h2 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h2><p>首先，在项目根目录创建 TypeScript 的配置文件 <code>tsconfig.json</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ touch tsconfig.json</span><br></pre></td></tr></table></figure>

<p>然后，执行 <code>npm run dev</code> 或 <code>yarn dev</code>，NextJS 将自动配置 TypeScript 的默认值到 <code>tsconfig.json</code> 文件中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yarn dev</span><br><span class="line">yarn run v1.22.17</span><br><span class="line">$ next dev</span><br><span class="line">ready - started server on 0.0.0.0:3000, url: http://localhost:3000</span><br><span class="line">It looks like you<span class="string">&#x27;re trying to use TypeScript but do not have the required package(s) installed.</span></span><br><span class="line"><span class="string">Installing dependencies</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">If you are not trying to use TypeScript, please remove the tsconfig.json file from your package root (and any TypeScript files in your pages directory).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Installing devDependencies (yarn):</span></span><br><span class="line"><span class="string">- typescript</span></span><br><span class="line"><span class="string">- @types/react</span></span><br><span class="line"><span class="string">- @types/node</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">wait  - compiling / (client and server)...</span></span><br><span class="line"><span class="string">event - compiled client and server successfully in 119 ms (207 modules)</span></span><br></pre></td></tr></table></figure>

<p>除此之外，NextJS 还会在项目根目录额外创建一个 <code>next-env.d.ts</code> 文件，这个文件默认忽略提交并且不要手动修改，因为这个文件在项目编译时可能随时被更改。而若要提供全局类型，可以新增一个 <code>additional.d.ts</code> 文件用来提供项目全局类型。不要忘记将 <code>additional.d.ts</code> 文件添加到 <code>tsconfig.json</code> 配置文件中，通常是添加到 <code>include</code> 数组中即可。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;include&quot;</span>: [<span class="string">&quot;next-env.d.ts&quot;</span>, <span class="string">&quot;additional.d.ts&quot;</span>, <span class="string">&quot;**/*.ts&quot;</span>, <span class="string">&quot;**/*.tsx&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上，是在 NextJS 项目中添加 TypeScript 的两种方式。</p>
<div class="post-ggad"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-6487844781006261" data-ad-slot="3432081921"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div>]]></content>
  </entry>
  <entry>
    <title>prefers-color-scheme 设置、检测系统主题色</title>
    <url>/post/prefers-color-scheme-%E8%AE%BE%E7%BD%AE%E3%80%81%E6%A3%80%E6%B5%8B%E7%B3%BB%E7%BB%9F%E4%B8%BB%E9%A2%98%E8%89%B2/</url>
    <content><![CDATA[<p>我们在访问某个站点时，有时可能会发现这样一种场景：该站点在白天访问时，它是亮色主题；当晚上访问时，它就变成暗色主题了。而且这种主题的切换是自动的，他会随系统主题变化而改变。如果我们要将这种功能应用在自己站点上，该如何实现呢？</p>
<p>本文涉及三个相关知识点：</p>
<ol>
<li>设置主题色</li>
<li>检查主题色</li>
<li>监听主题色变化</li>
</ol>
<span id="more"></span>

<h2 id="设置主题色"><a href="#设置主题色" class="headerlink" title="设置主题色"></a>设置主题色</h2><p>在 CSS 中，提供了一种设置系统主题色的媒体特性 <code>prefers-color-scheme</code>，该特性通常提供两个值 <code>light</code> 和 <code>dark</code>。顾名思义，这两个值一个代表 <code>日间模式</code>，一个表示 <code>夜间模式</code>。并且他们的兼容性也是最好的。</p>
<p><img src="https://www.hi-ruofei.com/usr/uploads/2022/09/4286262697.png" alt="prefers-color-scheme 兼容性"></p>
<p>这里有一个简单的例子，可以很方便的通过 CSS 实现系统主题色：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.day</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#eee</span>;</span><br><span class="line">  <span class="attribute">color</span>: black;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.night</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#333</span>;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">prefers-color-scheme</span>: dark) &#123;</span><br><span class="line">  <span class="selector-class">.day</span><span class="selector-class">.dark-scheme</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#333</span>;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.night</span><span class="selector-class">.dark-scheme</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: black;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#ddd</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">prefers-color-scheme</span>: light) &#123;</span><br><span class="line">  <span class="selector-class">.day</span><span class="selector-class">.light-scheme</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: white;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#555</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.night</span><span class="selector-class">.light-scheme</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#eee</span>;</span><br><span class="line">    <span class="attribute">color</span>: black;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当系统主题为日间模式时，会应用上面的 light 主题样式；当系统主题为夜间模式时，会应用上面的 dark 主题样式。</p>
<p>实际开发中，我们会将项目用到的色值抽离出来作为全局的公共变量，方便我们对项目整体的色值管理。如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  // Light Theme</span><br><span class="line">  --PrimaryBackgroundColorLight: <span class="number">#f9f9f9</span>;</span><br><span class="line">  --PageBackgroundColorLight: <span class="number">#efefef</span>;</span><br><span class="line">  --PrimaryColorLight: <span class="number">#34495e</span>;</span><br><span class="line">  --PrimaryActivedColorLight: <span class="number">#1890ff</span>;</span><br><span class="line"></span><br><span class="line">  // Dark Theme</span><br><span class="line">  --PrimaryBackgroundColorDark: <span class="number">#293042</span>;</span><br><span class="line">  --PageBackgroundColorDark: <span class="number">#202634</span>;</span><br><span class="line">  --PrimaryColorDark: <span class="number">#c6cfd8</span>;</span><br><span class="line">  --PrimaryActivedColorDark: <span class="number">#1890ff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们定义好全局 CSS 变量后，在需要的地方直接引用即可：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.day</span><span class="selector-class">.light</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">var</span>(--PrimaryBackgroundColorLight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="检测主题色"><a href="#检测主题色" class="headerlink" title="检测主题色"></a>检测主题色</h2><p>既然能通过 CSS 设置系统主题色，那 JS 肯定也有能力来检测系统主题色。JS 提供了一个用于检查媒体查询的函数 <code>matchMedia</code>，利用该函数能方便地检查当前系统主题色：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> themeMedia = <span class="built_in">window</span>.matchMedia(<span class="string">&quot;(prefers-color-scheme: light)&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (themeMedia.matches) &#123;</span><br><span class="line">  <span class="comment">// 日间模式</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 夜间模式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="监听主题色变化"><a href="#监听主题色变化" class="headerlink" title="监听主题色变化"></a>监听主题色变化</h2><p>除了获取当前系统主题色，我们还能监听主题色的变化。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> themeMedia = <span class="built_in">window</span>.matchMedia(<span class="string">&quot;(prefers-color-scheme: light)&quot;</span>);</span><br><span class="line">themeMedia.addListener(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (e.matches) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;light&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;dark&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>通过上面提到的三个知识点，在自己站点实现主题色功能是绰绰有余的。像一些更丰富的多主题切换，虽然实现的方法不同，但思路基本都是类似的。总结起来就是开篇的三句话：如何设置主题、获取当前被应用的主题以及监听主题的变更。</p>
<p>以上，希望对你有所帮助。</p>
<div class="post-ggad"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-6487844781006261" data-ad-slot="3432081921"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div>]]></content>
      <categories>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title>404</title>
    <url>//404.html</url>
    <content><![CDATA[<p>哇哦，页面不见了～ 返回<a href="/">首页</a></p>
<div class="post-ggad"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-6487844781006261" data-ad-slot="3432081921"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div>]]></content>
  </entry>
  <entry>
    <title>Webpack</title>
    <url>/Webpack/index.html</url>
    <content><![CDATA[<h2 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h2><ul>
<li><a href="/post/6409f2be/">HtmlWebpackPlugin</a><div class="post-ggad"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-6487844781006261" data-ad-slot="3432081921"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>关于博主</title>
    <url>/about/index.html</url>
    <content><![CDATA[<h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><p>姓名：若非<br>描述：爱编码，爱生活，爱分享<br>技术栈：Hexo、NexT、GitHub Action</p>
<p>说来惭愧，博主从 2017 年开始就断断续续地写博客，不过中间一直没有坚持下来。 2020 年底决定「从头再来」。目前博主只运营了这一个博客站，主要内容以前端开发为主，也会有一些周边工具的介绍和编码技巧的总结，希望我写的文字能帮助到有缘来到本站的朋友，有任何想法欢迎留言讨论。</p>
<p>本站采用 Hexo + NexT 搭建，有想自己运营一个类似的博客的朋友也欢迎来咨询。</p>
<h2 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a><a href="/links">友情链接</a></h2><p>以下为本站定期访问的友链网站，如果你希望加入博主定期访问的项目里，请你保持定期更新网站！希望添加友情链接的请先添加本站链接再留言，这是约定成俗的规矩，如果贵站不适合本站链接，我会在你博客友链页说明。注：采集站，非法站一律不接受链接！</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://hi-ruofei.com/&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;若非的日志&quot;</span>&gt;</span>若非的日志<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>友链留言格式为：<br>站名：若非的日志<br>网址：<a href="https://hi-ruofei.com/">https://hi-ruofei.com</a><br>描述：爱编码，爱生活，爱分享</p>

<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-6487844781006261"
     data-ad-slot="3432081921"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

<div class="post-ggad"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-6487844781006261" data-ad-slot="3432081921"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div>]]></content>
  </entry>
  <entry>
    <title>books</title>
    <url>/books/index.html</url>
    <content><![CDATA[<ul>
<li><a href="https://books.hi-ruofei.com/54m0dfqx">JavaScript 高级程序设计（第 4 版）</a><ul>
<li><a href="https://books.hi-ruofei.com/54m0dfqx">在线阅读</a></li>
<li><a href="http://gofile.me/6gkca/aeWRSr9Pe">下载</a> - 关注微信公众号<strong>若非的日志</strong>，发送<strong>我爱阅读</strong>获取下载密码<div class="post-ggad"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-6487844781006261" data-ad-slot="3432081921"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>分类</title>
    <url>/categories/index.html</url>
    <content><![CDATA[<div class="post-ggad"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-6487844781006261" data-ad-slot="3432081921"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div>]]></content>
  </entry>
  <entry>
    <title>留言反馈</title>
    <url>/feedback/index.html</url>
    <content><![CDATA[<p>你可以：</p>
<ul>
<li>提建议；</li>
<li>随便写点什么；<div class="post-ggad"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-6487844781006261" data-ad-slot="3432081921"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>友情链接</title>
    <url>/links/index.html</url>
    <content><![CDATA[<h2 id="开发相关"><a href="#开发相关" class="headerlink" title="开发相关"></a>开发相关</h2><ul>
<li><a href="https://console.cloud.tencent.com/tcb/env/overview">云开发 CloudBase</a></li>
<li><a href="https://iwzo4eq4.mirror.aliyuncs.com/">Docker 镜像加速器</a></li>
<li><a href="https://docs.docker.com/">Docker Docs</a></li>
</ul>
<h2 id="站长工具"><a href="#站长工具" class="headerlink" title="站长工具"></a>站长工具</h2><ul>
<li><a href="https://ziyuan.baidu.com/dashboard/index?site=https://hi-ruofei.com">百度站长</a></li>
<li><a href="https://tongji.baidu.com/web/10000139264/homepage">百度统计</a></li>
<li><a href="https://search.google.com/search-console?resource_id=sc-domain:hi-ruofei.com">Google Search Console</a><div class="post-ggad"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-6487844781006261" data-ad-slot="3432081921"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>标签</title>
    <url>/tags/index.html</url>
    <content><![CDATA[<div class="post-ggad"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-6487844781006261" data-ad-slot="3432081921"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div>]]></content>
  </entry>
  <entry>
    <title>TypeScript</title>
    <url>/typescript/index.html</url>
    <content><![CDATA[<h2 id="Utility-Types-实用类型"><a href="#Utility-Types-实用类型" class="headerlink" title="Utility Types 实用类型"></a>Utility Types 实用类型</h2><p>该系列文章整理了 TypeScript 作用于全局的内置实用类型，这些实用类型都是由最基础的 TypeScript 语法编写而成。在开发 TypeScript 应用程序过程中，用好这些内置的实用类型可帮助我们减少业务代码量，还能让我们更容易地写出逻辑复杂的业务类型，同时也可以帮助我们夯实 TypeScript 基础。学好 TypeScript 内置的实用类型是向上进阶的必经之路。</p>
<ul>
<li><a href="/post/TypeScript-Utility-Types-Partial-TypeScript-%E5%AE%9E%E7%94%A8%E7%B1%BB%E5%9E%8B-Partial"><code>Partial&lt;Type&gt;</code></a>：将一个复合类型中的成员设为可选。</li>
<li><a href="/post/TypeScript-Utility-Types-Required-TypeScript-%E5%AE%9E%E7%94%A8%E7%B1%BB%E5%9E%8B-Required"><code>Required&lt;Type&gt;</code></a>：将一个复合类型中的成员设为必选。</li>
<li><a href="/post/TypeScript-Utility-Types-Readonly-TypeScript-%E5%AE%9E%E7%94%A8%E7%B1%BB%E5%9E%8B-Readonly"><code>Readonly&lt;Type&gt;</code></a>：将一个复合类型中的成员设为只读。</li>
<li><a href="/post/TypeScript-Utility-Types-Record-TypeScript-%E5%AE%9E%E7%94%A8%E7%B1%BB%E5%9E%8B-Record"><code>Record&lt;Keys, Type&gt;</code></a>：将一个复合类型中的成员映射到另一个复合类型以构造新类型。</li>
<li><a href="/post/TypeScript-Utility-Types-Pick-TypeScript-%E5%AE%9E%E7%94%A8%E7%B1%BB%E5%9E%8B-Pick"><code>Pick&lt;Type, Keys&gt;</code></a>：从一个复合类型中挑选若干属性键来构造新类型。</li>
<li><a href="/post/TypeScript-Utility-Types-Omit-TypeScript-%E5%AE%9E%E7%94%A8%E7%B1%BB%E5%9E%8B-Omit"><code>Omit&lt;Type, Keys&gt;</code></a>：从一个复合类型中选取所有属性并通过删除指定的成员来构造新类型。</li>
<li><a href="/post/TypeScript-Utility-Types-Exclude-TypeScript-%E5%AE%9E%E7%94%A8%E7%B1%BB%E5%9E%8B-Exclude"><code>Exclude&lt;Type, ExcludeUnion&gt;</code></a>：排除联合类型中的制定成员来构造新类型。</li>
<li><a href="/post/TypeScript-Utility-Types-Extract-TypeScript-%E5%AE%9E%E7%94%A8%E7%B1%BB%E5%9E%8B-Extract"><code>Extract&lt;T, U&gt;</code></a>：挑选出传入的两个联合类型中相同的成员，将这些相同的成员构造成一个新类型。</li>
<li><a href="/post/TypeScript-Utility-Types-NonNullable-TypeScript-%E5%AE%9E%E7%94%A8%E7%B1%BB%E5%9E%8B-NonNullable"><code>NonNullable&lt;Type&gt;</code></a>：排除联合类型中为 <code>null</code> 或 <code>undefined</code> 的成员，将剩下的成员构造成新类型。</li>
</ul>
<hr>
<div class="post-ggad"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-6487844781006261" data-ad-slot="3432081921"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div>]]></content>
  </entry>
  <entry>
    <title>更新日志</title>
    <url>/update-log/index.html</url>
    <content><![CDATA[<h2 id="2022-05-05"><a href="#2022-05-05" class="headerlink" title="2022.05.05"></a>2022.05.05</h2><ul>
<li>Update dependency hexo-generator-sitemap to v3.0.1</li>
<li>Update dependency hexo-theme-next to 8.11.1</li>
<li>Update dependency markdown-it to 13.0.1</li>
<li>Update dependency npm-check-updates to 12.5.11</li>
</ul>
<h2 id="2022-04-01"><a href="#2022-04-01" class="headerlink" title="2022.04.01"></a>2022.04.01</h2><ul>
<li>常规更新</li>
<li>Bing 网站验证</li>
</ul>
<h2 id="2022-03-10"><a href="#2022-03-10" class="headerlink" title="2022.03.10"></a>2022.03.10</h2><ul>
<li>Update dependency hexo-theme-next to v8.10.1</li>
<li>Update dependency node-gyp to v9.0.0</li>
<li>Update dependency npm-check-updates v12.5.2</li>
</ul>
<h2 id="2022-01-30"><a href="#2022-01-30" class="headerlink" title="2022.01.30"></a>2022.01.30</h2><ul>
<li>Update dependency hexo to v6.0.0</li>
<li>Update dependency hexo-renderer-marked to v5.0.0</li>
<li>Update dependency hexo-theme-next to v8.10.0</li>
<li>Update dependency npc-check-updates to v12.4.0</li>
</ul>
<h2 id="2022-01-30-1"><a href="#2022-01-30-1" class="headerlink" title="2022.01.30"></a>2022.01.30</h2><ul>
<li>尝试修复移动设备易用性问题</li>
</ul>
<h2 id="2022-01-27"><a href="#2022-01-27" class="headerlink" title="2022.01.27"></a>2022.01.27</h2><ul>
<li>Update dependency markdown-it to v12.3.2</li>
<li>Update dependency node-gyp to v8.4.1</li>
<li>Update dependency npm-check-updates to v12.2.1</li>
<li>Update dependency hexo to v6.0.0</li>
<li>Update dependency hexo-generator-sitemap to v2.2.0</li>
<li>Update dependency hexo-renderer-ejs to v2.0.0</li>
<li>Update dependency hexo-server to v3.0.0</li>
<li>Update dependency hexo-theme-next to v8.9.0</li>
</ul>
<h2 id="2021-10-17"><a href="#2021-10-17" class="headerlink" title="2021.10.17"></a>2021.10.17</h2><ul>
<li><code>hexo-theme-next</code>: ^8.7.1 → ^8.8.0</li>
</ul>
<h2 id="2021-09-27"><a href="#2021-09-27" class="headerlink" title="2021.09.27"></a>2021.09.27</h2><ul>
<li><code>npm-check-updates</code>: ^11.8.3 → ^11.8.5</li>
<li><code>hexo-generator-searchdb</code>: ^1.3.4 → ^1.4.0</li>
</ul>
<h2 id="2021-09-02"><a href="#2021-09-02" class="headerlink" title="2021.09.02"></a>2021.09.02</h2><ul>
<li>更新外部依赖：<br><code>hexo-theme-next</code>: ^8.7.0 -&gt; ^8.7.1<br><code>node-gyp</code>: ^8.1.0 -&gt; ^8.2.0</li>
<li>更新站点配置文件</li>
</ul>
<h2 id="2021-08-16"><a href="#2021-08-16" class="headerlink" title="2021.08.16"></a>2021.08.16</h2><ul>
<li><code>markdown-it</code>: ^12.0.6 → ^12.2.0</li>
<li><code>npm-check-updates</code>: ^11.8.0 → ^11.8.3</li>
<li><code>hexo-renderer-marked</code>: ^4.0.0 → ^4.1.0</li>
<li><code>hexo-theme-next</code>: ^8.6.1 → ^8.7.0</li>
</ul>
<h2 id="2021-07-02"><a href="#2021-07-02" class="headerlink" title="2021.07.02"></a>2021.07.02</h2><ul>
<li>更新外部依赖：<br><code>npm-check-updates@11.7.1</code> &#x3D;&gt; <code>npm-check-updates@11.8.0</code>. <a href="https://github.com/raineorshine/npm-check-updates/tree/v11.8.0">文档</a><br><code>hexo-theme-next@8.5.0</code> &#x3D;&gt; <code>hexo-theme-next@8.6.1</code>. <a href="https://theme-next.js.org/next-8-6-1-released/">文档</a></li>
</ul>
<h2 id="2021-06-26"><a href="#2021-06-26" class="headerlink" title="2021.06.26"></a>2021.06.26</h2><ul>
<li>文章渲染前自动在 post 页面底部（相关文章部分前面）插入谷歌广告</li>
<li>通过 <a href="https://www.npmjs.com/package/markdown-it"><code>markdown-it</code></a> 依赖在文章中实现 Markdown 脚注功能</li>
</ul>
<h2 id="2021-06-19"><a href="#2021-06-19" class="headerlink" title="2021.06.19"></a>2021.06.19</h2><ul>
<li>更新外部依赖：<code>npm-check-updates@11.6.0</code> &#x3D;&gt; <code>npm-check-updates@11.7.1</code>，<a href="https://github.com/raineorshine/npm-check-updates/tree/v11.7.1">文档</a></li>
<li>更新站点描述</li>
</ul>
<h2 id="2021-06-12"><a href="#2021-06-12" class="headerlink" title="2021.06.12"></a>2021.06.12</h2><ul>
<li>更新外部依赖</li>
<li>更新配置文件</li>
</ul>
<h2 id="2021-05-18"><a href="#2021-05-18" class="headerlink" title="2021.05.18"></a>2021.05.18</h2><ul>
<li>利用 jsDelivr 极大加速访问速度</li>
</ul>
<h2 id="2021-03-29"><a href="#2021-03-29" class="headerlink" title="2021.03.29"></a>2021.03.29</h2><ul>
<li>自定义 Tag：codepen</li>
<li>自动化发布 - 使用 vercel 托管静态站点，极大提高站点访问速度</li>
</ul>
<h2 id="2021-03-28"><a href="#2021-03-28" class="headerlink" title="2021.03.28"></a>2021.03.28</h2><ul>
<li>更新评论系统</li>
<li>添加「反馈」入口</li>
</ul>
<h2 id="2021-03-25"><a href="#2021-03-25" class="headerlink" title="2021.03.25"></a>2021.03.25</h2><ul>
<li>添加看板娘</li>
<li>sidebar 添加 Netlify 链接</li>
<li>配置第三方工具：<a href="https://widgetpack.com/">Widgetpack</a></li>
<li>安装 ShareButton</li>
</ul>
<h2 id="2021-03-19"><a href="#2021-03-19" class="headerlink" title="2021.03.19"></a>2021.03.19</h2><ul>
<li>更新外部依赖：<code>npm-check-updates@11.1.9</code> &#x3D;&gt; <code>npm-check-updates@11.3.0</code></li>
<li>更新站点配置文件</li>
</ul>
<h2 id="2021-03-01"><a href="#2021-03-01" class="headerlink" title="2021.03.01"></a>2021.03.01</h2><ul>
<li>更新外部依赖：<br><code>hexo@5.3.0</code> &#x3D;&gt; <code>hexo@5.4.0</code><br><code>hexo-lazyload-image@1.0.9</code> &#x3D;&gt; <code>hexo-lazyload-image@1.0.10</code><br><code>hexo-theme-next@8.2.1</code> &#x3D;&gt; <code>hexo-theme-next@8.2.2</code><br><code>npm-check-updates@11.1.4</code> &#x3D;&gt; <code>npm-check-updates@11.1.9</code></li>
<li>更新站点配置文件</li>
</ul>
<h2 id="2021-02-20"><a href="#2021-02-20" class="headerlink" title="2021.02.20"></a>2021.02.20</h2><ul>
<li>添加 360 站点验证代码</li>
<li>添加 360 自动收录代码</li>
</ul>
<h2 id="2021-02-18"><a href="#2021-02-18" class="headerlink" title="2021.02.18"></a>2021.02.18</h2><ul>
<li>更新第三方依赖：<br><code>hexo-deployer-git@2.1.0</code> &#x3D;&gt; <code>hexo-deployer-git@3.0.0</code><br><code>hexo-renderer-marked@3.3.0</code> &#x3D;&gt; <code>hexo-renderer-marked@4.0.0</code><br><code>hexo-theme-next@8.2.0</code> &#x3D;&gt; <code>hexo-theme-next@8.2.1</code><br><code>npm-check-updates@11.1.0</code> &#x3D;&gt; <code>npm-check-updates@11.1.4</code></li>
</ul>
<h2 id="2021-01-27"><a href="#2021-01-27" class="headerlink" title="2021.01.27"></a>2021.01.27</h2><ul>
<li>更新站点配置文件</li>
</ul>
<h2 id="2021-01-26"><a href="#2021-01-26" class="headerlink" title="2021.01.26"></a>2021.01.26</h2><ul>
<li>更新第三方依赖：<code>npm-check-updates@11.0.2</code> &#x3D;&gt; <code>npm-check-updates@11.1.0</code></li>
</ul>
<h2 id="2021-01-24"><a href="#2021-01-24" class="headerlink" title="2021.01.24"></a>2021.01.24</h2><ul>
<li>更新第三方依赖：<code>npm-check-updates@10.2.5</code> &#x3D;&gt; <code>npm-check-updates@11.0.2</code></li>
</ul>
<h2 id="2021-01-17"><a href="#2021-01-17" class="headerlink" title="2021.01.17"></a>2021.01.17</h2><ul>
<li>修改 hexo 模板文件</li>
</ul>
<h2 id="2021-01-14"><a href="#2021-01-14" class="headerlink" title="2021.01.14"></a>2021.01.14</h2><ul>
<li>移除第三方依赖：<br><code>hexo-baidu-url-submit@0.0.6</code><br><code>xmlhttprequest@1.8.0</code></li>
<li>编写 hexo 插件，实现 hexo-baidu-url-submit 类似的功能</li>
</ul>
<h2 id="2021-01-09"><a href="#2021-01-09" class="headerlink" title="2021.01.09"></a>2021.01.09</h2><ul>
<li>更新站点配置文件</li>
<li>新增 robots.txt 文件</li>
</ul>
<h2 id="2021-01-05"><a href="#2021-01-05" class="headerlink" title="2021.01.05"></a>2021.01.05</h2><ul>
<li>修改「统计」地址</li>
</ul>
<h2 id="2021-01-04"><a href="#2021-01-04" class="headerlink" title="2021.01.04"></a>2021.01.04</h2><ul>
<li>更新外部依赖：<code>hexo-theme-next@8.1.0</code> &#x3D;&gt; <code>hexo-theme-next@8.2.0</code></li>
</ul>
<h2 id="2021-01-03"><a href="#2021-01-03" class="headerlink" title="2021.01.03"></a>2021.01.03</h2><ul>
<li>更新站点配置文件</li>
</ul>
<h2 id="2021-01-02"><a href="#2021-01-02" class="headerlink" title="2021.01.02"></a>2021.01.02</h2><ul>
<li>Yandex 验证网站所有者</li>
</ul>
<h2 id="2020-11-31"><a href="#2020-11-31" class="headerlink" title="2020.11.31"></a>2020.11.31</h2><ul>
<li>填写备案号</li>
<li>更新百度统计验证代码</li>
</ul>
<h2 id="2020-11-29"><a href="#2020-11-29" class="headerlink" title="2020.11.29"></a>2020.11.29</h2><ul>
<li>添加百度统计代码</li>
<li>添加网址导航</li>
<li>更新邮件地址</li>
<li>配置重定向</li>
<li>安装百度统计代码</li>
<li>添加百度联盟验证信息</li>
</ul>
<h2 id="2020-11-23"><a href="#2020-11-23" class="headerlink" title="2020.11.23"></a>2020.11.23</h2><ul>
<li>外部依赖更新：<code>hexo@5.2.0</code> &#x3D;&gt; <code>hexo@5.3.0</code></li>
</ul>
<h2 id="2020-11-19"><a href="#2020-11-19" class="headerlink" title="2020.11.19"></a>2020.11.19</h2><ul>
<li>更新百度搜索验证文件</li>
</ul>
<h2 id="2020-11-18"><a href="#2020-11-18" class="headerlink" title="2020.11.18"></a>2020.11.18</h2><ul>
<li>添加百度搜索验证文件</li>
</ul>
<h2 id="2020-11-17"><a href="#2020-11-17" class="headerlink" title="2020.11.17"></a>2020.11.17</h2><ul>
<li>添加外部依赖：<a href="https://www.npmjs.com/package/hexo-baidu-url-submit"><code>hexo-baidu-url-submit</code></a></li>
<li>添加搜狗搜索验证文件</li>
</ul>
<h2 id="2020-11-16"><a href="#2020-11-16" class="headerlink" title="2020.11.16"></a>2020.11.16</h2><ul>
<li>借助 GitHub Actions 实现博客的自动化部署和发布<div class="post-ggad"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-6487844781006261" data-ad-slot="3432081921"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></li>
</ul>
]]></content>
  </entry>
</search>
